{"version":3,"sources":["meteor://ðŸ’»app/packages/cfs_collection/packages/cfs_collection.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2E","file":"/packages/cfs_collection.js","sourcesContent":["(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/cfs:collection/common.js                                                                                   //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/**                                                                                                                    // 1\n *                                                                                                                     // 2\n * @constructor                                                                                                        // 3\n * @param {string} name A name for the collection                                                                      // 4\n * @param {Object} options                                                                                             // 5\n * @param {FS.StorageAdapter[]} options.stores An array of stores in which files should be saved. At least one is required.\n * @param {Object} [options.filter] Filter definitions                                                                 // 7\n * @param {Number} [options.chunkSize=2MB] Override the chunk size in bytes for uploads                                // 8\n * @param {Function} [options.uploader] A function to pass FS.File instances after inserting, which will begin uploading them. By default, `FS.HTTP.uploadQueue.uploadFile` is used if the `cfs-upload-http` package is present, or `FS.DDP.uploadQueue.uploadFile` is used if the `cfs-upload-ddp` package is present. You can override with your own, or set to `null` to prevent automatic uploading.\n * @returns {undefined}                                                                                                // 10\n */                                                                                                                    // 11\nFS.Collection = function(name, options) {                                                                              // 12\n  var self = this;                                                                                                     // 13\n                                                                                                                       // 14\n  self.storesLookup = {};                                                                                              // 15\n                                                                                                                       // 16\n  self.primaryStore = {};                                                                                              // 17\n                                                                                                                       // 18\n  self.options = {                                                                                                     // 19\n    filter: null, //optional                                                                                           // 20\n    stores: [], //required                                                                                             // 21\n    chunkSize: null                                                                                                    // 22\n  };                                                                                                                   // 23\n                                                                                                                       // 24\n  // Define a default uploader based on which upload packages are present,                                             // 25\n  // preferring HTTP. You may override with your own function or                                                       // 26\n  // set to null to skip automatic uploading of data after file insert/update.                                         // 27\n  if (FS.HTTP && FS.HTTP.uploadQueue) {                                                                                // 28\n    self.options.uploader = FS.HTTP.uploadQueue.uploadFile;                                                            // 29\n  } else if (FS.DDP && FS.DDP.uploadQueue) {                                                                           // 30\n    self.options.uploader = FS.DDP.uploadQueue.uploadFile;                                                             // 31\n  }                                                                                                                    // 32\n                                                                                                                       // 33\n  // Extend and overwrite options                                                                                      // 34\n  FS.Utility.extend(self.options, options || {});                                                                      // 35\n                                                                                                                       // 36\n  // Set the FS.Collection name                                                                                        // 37\n  self.name = name;                                                                                                    // 38\n                                                                                                                       // 39\n  // Make sure at least one store has been supplied.                                                                   // 40\n  // Usually the stores aren't used on the client, but we need them defined                                            // 41\n  // so that we can access their names and use the first one as the default.                                           // 42\n  if (FS.Utility.isEmpty(self.options.stores)) {                                                                       // 43\n    throw new Error(\"You must specify at least one store. Please consult the documentation.\");                         // 44\n  }                                                                                                                    // 45\n                                                                                                                       // 46\n  FS.Utility.each(self.options.stores, function(store, i) {                                                            // 47\n    // Set the primary store                                                                                           // 48\n    if (i === 0) {                                                                                                     // 49\n      self.primaryStore = store;                                                                                       // 50\n    }                                                                                                                  // 51\n                                                                                                                       // 52\n    // Check for duplicate naming                                                                                      // 53\n    if (typeof self.storesLookup[store.name] !== 'undefined') {                                                        // 54\n      throw new Error('FS.Collection store names must be uniq, duplicate found: ' + store.name);                       // 55\n    }                                                                                                                  // 56\n                                                                                                                       // 57\n    // Set the lookup                                                                                                  // 58\n    self.storesLookup[store.name] = store;                                                                             // 59\n                                                                                                                       // 60\n    if (Meteor.isServer) {                                                                                             // 61\n                                                                                                                       // 62\n      // Emit events based on store events                                                                             // 63\n      store.on('stored', function (storeName, fileObj) {                                                               // 64\n        // This is weird, but currently there is a bug where each store will emit the                                  // 65\n        // events for all other stores, too, so we need to make sure that this event                                   // 66\n        // is truly for this store.                                                                                    // 67\n        if (storeName !== store.name)                                                                                  // 68\n          return;                                                                                                      // 69\n        // When a file is successfully stored into the store, we emit a \"stored\" event on the FS.Collection only if the file belongs to this collection\n        if (fileObj.collectionName === name) {                                                                         // 71\n          var emitted = self.emit('stored', fileObj, store.name);                                                      // 72\n          if (FS.debug && !emitted) {                                                                                  // 73\n            console.log(fileObj.name({store: store.name}) + ' was successfully saved to the ' + store.name + ' store. You are seeing this informational message because you enabled debugging and you have not defined any listeners for the \"stored\" event on the ' + name + ' collection.');\n          }                                                                                                            // 75\n        }                                                                                                              // 76\n        fileObj.emit('stored', store.name);                                                                            // 77\n      });                                                                                                              // 78\n                                                                                                                       // 79\n      store.on('error', function (storeName, error, fileObj) {                                                         // 80\n        // This is weird, but currently there is a bug where each store will emit the                                  // 81\n        // events for all other stores, too, so we need to make sure that this event                                   // 82\n        // is truly for this store.                                                                                    // 83\n        if (storeName !== store.name)                                                                                  // 84\n          return;                                                                                                      // 85\n        // When a file has an error while being stored into the temp store, we emit an \"error\" event on the FS.Collection only if the file belongs to this collection\n        if (fileObj.collectionName === name) {                                                                         // 87\n          error = new Error('Error storing file to the ' + store.name + ' store: ' + error.message);                   // 88\n          var emitted = self.emit('error', error, fileObj, store.name);                                                // 89\n          if (FS.debug && !emitted) {                                                                                  // 90\n            console.log(error.message);                                                                                // 91\n          }                                                                                                            // 92\n        }                                                                                                              // 93\n        fileObj.emit('error', store.name);                                                                             // 94\n      });                                                                                                              // 95\n                                                                                                                       // 96\n    }                                                                                                                  // 97\n  });                                                                                                                  // 98\n                                                                                                                       // 99\n  var _filesOptions = {                                                                                                // 100\n    transform: function(doc) {                                                                                         // 101\n      // This should keep the filerecord in the file object updated in reactive                                        // 102\n      // context                                                                                                       // 103\n      var result = new FS.File(doc, true);                                                                             // 104\n      result.collectionName = name;                                                                                    // 105\n      return result;                                                                                                   // 106\n    }                                                                                                                  // 107\n  };                                                                                                                   // 108\n                                                                                                                       // 109\n  // Create the 'cfs.' ++ \".filerecord\" and use fsFile                                                                 // 110\n  var collectionName = 'cfs.' + name + '.filerecord';                                                                  // 111\n  self.files = new Mongo.Collection(collectionName, _filesOptions);                                                    // 112\n                                                                                                                       // 113\n  // For storing custom allow/deny functions                                                                           // 114\n  self._validators = {                                                                                                 // 115\n    download: {allow: [], deny: []}                                                                                    // 116\n  };                                                                                                                   // 117\n                                                                                                                       // 118\n  // Set up filters                                                                                                    // 119\n  // XXX Should we deprecate the filter option now that this is done with a separate pkg, or just keep it?             // 120\n  if (self.filters) {                                                                                                  // 121\n    self.filters(self.options.filter);                                                                                 // 122\n  }                                                                                                                    // 123\n                                                                                                                       // 124\n  // Save the collection reference (we want it without the 'cfs.' prefix and '.filerecord' suffix)                     // 125\n  FS._collections[name] = this;                                                                                        // 126\n                                                                                                                       // 127\n  // Set up observers                                                                                                  // 128\n  Meteor.isServer && FS.FileWorker && FS.FileWorker.observe(this);                                                     // 129\n                                                                                                                       // 130\n  // Emit \"removed\" event on collection                                                                                // 131\n  self.files.find().observe({                                                                                          // 132\n    removed: function(fileObj) {                                                                                       // 133\n      self.emit('removed', fileObj);                                                                                   // 134\n    }                                                                                                                  // 135\n  });                                                                                                                  // 136\n                                                                                                                       // 137\n  // Emit events based on TempStore events                                                                             // 138\n  if (FS.TempStore) {                                                                                                  // 139\n    FS.TempStore.on('stored', function (fileObj, result) {                                                             // 140\n      // When a file is successfully stored into the temp store, we emit an \"uploaded\" event on the FS.Collection only if the file belongs to this collection\n      if (fileObj.collectionName === name) {                                                                           // 142\n        var emitted = self.emit('uploaded', fileObj);                                                                  // 143\n        if (FS.debug && !emitted) {                                                                                    // 144\n          console.log(fileObj.name() + ' was successfully uploaded. You are seeing this informational message because you enabled debugging and you have not defined any listeners for the \"uploaded\" event on the ' + name + ' collection.');\n        }                                                                                                              // 146\n      }                                                                                                                // 147\n    });                                                                                                                // 148\n                                                                                                                       // 149\n    FS.TempStore.on('error', function (error, fileObj) {                                                               // 150\n      // When a file has an error while being stored into the temp store, we emit an \"error\" event on the FS.Collection only if the file belongs to this collection\n      if (fileObj.collectionName === name) {                                                                           // 152\n        self.emit('error', new Error('Error storing uploaded file to TempStore: ' + error.message), fileObj);          // 153\n      }                                                                                                                // 154\n    });                                                                                                                // 155\n  } else if (Meteor.isServer) {                                                                                        // 156\n    throw new Error(\"FS.Collection constructor: FS.TempStore must be defined before constructing any FS.Collections.\") // 157\n  }                                                                                                                    // 158\n                                                                                                                       // 159\n};                                                                                                                     // 160\n                                                                                                                       // 161\n// An FS.Collection can emit events                                                                                    // 162\nFS.Collection.prototype = new EventEmitter();                                                                          // 163\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                     //\n// packages/cfs:collection/api.common.js                                                                               //\n//                                                                                                                     //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                       //\n/** @method FS.Collection.prototype.insert Insert `File` or `FS.File` or remote URL into collection                    // 1\n * @public                                                                                                             // 2\n * @param {File|Blob|Buffer|ArrayBuffer|Uint8Array|String} fileRef File, FS.File, or other data to insert              // 3\n * @param {function} [callback] Callback `function(error, fileObj)`                                                    // 4\n * @returns {FS.File|undefined} The `file object`                                                                      // 5\n * [Meteor docs](http://docs.meteor.com/#insert)                                                                       // 6\n */                                                                                                                    // 7\nFS.Collection.prototype.insert = function(fileRef, callback) {                                                         // 8\n  var self = this;                                                                                                     // 9\n                                                                                                                       // 10\n  if (Meteor.isClient && !callback) {                                                                                  // 11\n    callback = FS.Utility.defaultCallback;                                                                             // 12\n  }                                                                                                                    // 13\n                                                                                                                       // 14\n  // XXX:                                                                                                              // 15\n  // We should out factor beginStorage to FS.File.beginStorage                                                         // 16\n  // the client side storage adapters should be the one providing                                                      // 17\n  // the upload either via http/ddp or direct upload                                                                   // 18\n  // Could be cool to have a streaming api on the client side                                                          // 19\n  // having a createReadStream etc. on the client too...                                                               // 20\n  function beginStorage(fileObj) {                                                                                     // 21\n                                                                                                                       // 22\n    // If on client, begin uploading the data                                                                          // 23\n    if (Meteor.isClient) {                                                                                             // 24\n      self.options.uploader && self.options.uploader(fileObj);                                                         // 25\n    }                                                                                                                  // 26\n                                                                                                                       // 27\n    // If on the server, save the binary to a single chunk temp file,                                                  // 28\n    // so that it is available when FileWorker calls saveCopies.                                                       // 29\n    // This will also trigger file handling from collection observes.                                                  // 30\n    else if (Meteor.isServer) {                                                                                        // 31\n      fileObj.createReadStream().pipe(FS.TempStore.createWriteStream(fileObj));                                        // 32\n    }                                                                                                                  // 33\n  }                                                                                                                    // 34\n                                                                                                                       // 35\n  // XXX: would be great if this function could be simplyfied - if even possible?                                      // 36\n  function checkAndInsert(fileObj) {                                                                                   // 37\n    // Check filters. This is called in deny functions, too, but we call here to catch                                 // 38\n    // server inserts and to catch client inserts early, allowing us to call `onInvalid` on                            // 39\n    // the client and save a trip to the server.                                                                       // 40\n    if (!self.allowsFile(fileObj)) {                                                                                   // 41\n      return FS.Utility.handleError(callback, 'FS.Collection insert: file does not pass collection filters');          // 42\n    }                                                                                                                  // 43\n                                                                                                                       // 44\n    // Set collection name                                                                                             // 45\n    fileObj.collectionName = self.name;                                                                                // 46\n                                                                                                                       // 47\n    // Insert the file into db                                                                                         // 48\n    // We call cloneFileRecord as an easy way of extracting the properties                                             // 49\n    // that need saving.                                                                                               // 50\n    if (callback) {                                                                                                    // 51\n      fileObj._id = self.files.insert(FS.Utility.cloneFileRecord(fileObj), function(err, id) {                         // 52\n        if (err) {                                                                                                     // 53\n          if (fileObj._id) {                                                                                           // 54\n            delete fileObj._id;                                                                                        // 55\n          }                                                                                                            // 56\n        } else {                                                                                                       // 57\n          // Set _id, just to be safe, since this could be before or after the insert method returns                   // 58\n          fileObj._id = id;                                                                                            // 59\n          // Pass to uploader or stream data to the temp store                                                         // 60\n          beginStorage(fileObj);                                                                                       // 61\n        }                                                                                                              // 62\n        callback(err, err ? void 0 : fileObj);                                                                         // 63\n      });                                                                                                              // 64\n    } else {                                                                                                           // 65\n      fileObj._id = self.files.insert(FS.Utility.cloneFileRecord(fileObj));                                            // 66\n      // Pass to uploader or stream data to the temp store                                                             // 67\n      beginStorage(fileObj);                                                                                           // 68\n    }                                                                                                                  // 69\n    return fileObj;                                                                                                    // 70\n  }                                                                                                                    // 71\n                                                                                                                       // 72\n  // Parse, adjust fileRef                                                                                             // 73\n  if (fileRef instanceof FS.File) {                                                                                    // 74\n    return checkAndInsert(fileRef);                                                                                    // 75\n  } else {                                                                                                             // 76\n    // For convenience, allow File, Blob, Buffer, data URI, filepath, URL, etc. to be passed as first arg,             // 77\n    // and we will attach that to a new fileobj for them                                                               // 78\n    var fileObj = new FS.File(fileRef);                                                                                // 79\n    if (callback) {                                                                                                    // 80\n      fileObj.attachData(fileRef, function attachDataCallback(error) {                                                 // 81\n        if (error) {                                                                                                   // 82\n          callback(error);                                                                                             // 83\n        } else {                                                                                                       // 84\n          checkAndInsert(fileObj);                                                                                     // 85\n        }                                                                                                              // 86\n      });                                                                                                              // 87\n    } else {                                                                                                           // 88\n      // We ensure there's a callback on the client, so if there isn't one at this point,                              // 89\n      // we must be on the server expecting synchronous behavior.                                                      // 90\n      fileObj.attachData(fileRef);                                                                                     // 91\n      checkAndInsert(fileObj);                                                                                         // 92\n    }                                                                                                                  // 93\n    return fileObj;                                                                                                    // 94\n  }                                                                                                                    // 95\n};                                                                                                                     // 96\n                                                                                                                       // 97\n/** @method FS.Collection.prototype.update Update the file record                                                      // 98\n * @public                                                                                                             // 99\n * @param {FS.File|object} selector                                                                                    // 100\n * @param {object} modifier                                                                                            // 101\n * @param {object} [options]                                                                                           // 102\n * @param {function} [callback]                                                                                        // 103\n * [Meteor docs](http://docs.meteor.com/#update)                                                                       // 104\n */                                                                                                                    // 105\nFS.Collection.prototype.update = function(selector, modifier, options, callback) {                                     // 106\n  var self = this;                                                                                                     // 107\n  if (selector instanceof FS.File) {                                                                                   // 108\n    // Make sure the file belongs to this FS.Collection                                                                // 109\n    if (selector.collectionName === self.files._name) {                                                                // 110\n      return selector.update(modifier, options, callback);                                                             // 111\n    } else {                                                                                                           // 112\n      // Tried to save a file in the wrong FS.Collection                                                               // 113\n      throw new Error('FS.Collection cannot update file belongs to: \"' + selector.collectionName + '\" not: \"' + self.files._name + '\"');\n    }                                                                                                                  // 115\n  }                                                                                                                    // 116\n                                                                                                                       // 117\n  return self.files.update(selector, modifier, options, callback);                                                     // 118\n};                                                                                                                     // 119\n                                                                                                                       // 120\n/** @method FS.Collection.prototype.remove Remove the file from the collection                                         // 121\n * @public                                                                                                             // 122\n * @param {FS.File|object} selector                                                                                    // 123\n * @param {Function} [callback]                                                                                        // 124\n * [Meteor docs](http://docs.meteor.com/#remove)                                                                       // 125\n */                                                                                                                    // 126\nFS.Collection.prototype.remove = function(selector, callback) {                                                        // 127\n  var self = this;                                                                                                     // 128\n  if (selector instanceof FS.File) {                                                                                   // 129\n                                                                                                                       // 130\n    // Make sure the file belongs to this FS.Collection                                                                // 131\n    if (selector.collectionName === self.files._name) {                                                                // 132\n      return selector.remove(callback);                                                                                // 133\n    } else {                                                                                                           // 134\n      // Tried to remove a file from the wrong FS.Collection                                                           // 135\n      throw new Error('FS.Collection cannot remove file belongs to: \"' + selector.collectionName + '\" not: \"' + self.files._name + '\"');\n    }                                                                                                                  // 137\n  }                                                                                                                    // 138\n                                                                                                                       // 139\n  //doesn't work correctly on the client without a callback                                                            // 140\n  callback = callback || FS.Utility.defaultCallback;                                                                   // 141\n  return self.files.remove(selector, callback);                                                                        // 142\n};                                                                                                                     // 143\n                                                                                                                       // 144\n/** @method FS.Collection.prototype.findOne                                                                            // 145\n * @public                                                                                                             // 146\n * @param {[selector](http://docs.meteor.com/#selectors)} selector                                                     // 147\n * [Meteor docs](http://docs.meteor.com/#findone)                                                                      // 148\n * Example:                                                                                                            // 149\n ```js                                                                                                                 // 150\n var images = new FS.Collection( ... );                                                                                // 151\n // Get the file object                                                                                                // 152\n var fo = images.findOne({ _id: 'NpnskCt6ippN6CgD8' });                                                                // 153\n ```                                                                                                                   // 154\n */                                                                                                                    // 155\n// Call findOne on files collection                                                                                    // 156\nFS.Collection.prototype.findOne = function(selector) {                                                                 // 157\n  var self = this;                                                                                                     // 158\n  return self.files.findOne.apply(self.files, arguments);                                                              // 159\n};                                                                                                                     // 160\n                                                                                                                       // 161\n/** @method FS.Collection.prototype.find                                                                               // 162\n * @public                                                                                                             // 163\n * @param {[selector](http://docs.meteor.com/#selectors)} selector                                                     // 164\n * [Meteor docs](http://docs.meteor.com/#find)                                                                         // 165\n * Example:                                                                                                            // 166\n ```js                                                                                                                 // 167\n var images = new FS.Collection( ... );                                                                                // 168\n // Get the all file objects                                                                                           // 169\n var files = images.find({ _id: 'NpnskCt6ippN6CgD8' }).fetch();                                                        // 170\n ```                                                                                                                   // 171\n */                                                                                                                    // 172\nFS.Collection.prototype.find = function(selector) {                                                                    // 173\n  var self = this;                                                                                                     // 174\n  return self.files.find.apply(self.files, arguments);                                                                 // 175\n};                                                                                                                     // 176\n                                                                                                                       // 177\n/** @method FS.Collection.prototype.allow                                                                              // 178\n * @public                                                                                                             // 179\n * @param {object} options                                                                                             // 180\n * @param {function} options.download Function that checks if the file contents may be downloaded                      // 181\n * @param {function} options.insert                                                                                    // 182\n * @param {function} options.update                                                                                    // 183\n * @param {function} options.remove Functions that look at a proposed modification to the database and return true if it should be allowed\n * @param {[string]} [options.fetch] Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your update and remove functions\n * [Meteor docs](http://docs.meteor.com/#allow)                                                                        // 186\n * Example:                                                                                                            // 187\n ```js                                                                                                                 // 188\n var images = new FS.Collection( ... );                                                                                // 189\n // Get the all file objects                                                                                           // 190\n var files = images.allow({                                                                                            // 191\n insert: function(userId, doc) { return true; },                                                                       // 192\n update: function(userId, doc, fields, modifier) { return true; },                                                     // 193\n remove: function(userId, doc) { return true; },                                                                       // 194\n download: function(userId, fileObj) { return true; },                                                                 // 195\n });                                                                                                                   // 196\n ```                                                                                                                   // 197\n */                                                                                                                    // 198\nFS.Collection.prototype.allow = function(options) {                                                                    // 199\n  var self = this;                                                                                                     // 200\n                                                                                                                       // 201\n  // Pull out the custom \"download\" functions                                                                          // 202\n  if (options.download) {                                                                                              // 203\n    if (!(options.download instanceof Function)) {                                                                     // 204\n      throw new Error(\"allow: Value for `download` must be a function\");                                               // 205\n    }                                                                                                                  // 206\n    self._validators.download.allow.push(options.download);                                                            // 207\n    delete options.download;                                                                                           // 208\n  }                                                                                                                    // 209\n                                                                                                                       // 210\n  return self.files.allow.call(self.files, options);                                                                   // 211\n};                                                                                                                     // 212\n                                                                                                                       // 213\n/** @method FS.Collection.prototype.deny                                                                               // 214\n * @public                                                                                                             // 215\n * @param {object} options                                                                                             // 216\n * @param {function} options.download Function that checks if the file contents may be downloaded                      // 217\n * @param {function} options.insert                                                                                    // 218\n * @param {function} options.update                                                                                    // 219\n * @param {function} options.remove Functions that look at a proposed modification to the database and return true if it should be denyed\n * @param {[string]} [options.fetch] Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your update and remove functions\n * [Meteor docs](http://docs.meteor.com/#deny)                                                                         // 222\n * Example:                                                                                                            // 223\n ```js                                                                                                                 // 224\n var images = new FS.Collection( ... );                                                                                // 225\n // Get the all file objects                                                                                           // 226\n var files = images.deny({                                                                                             // 227\n insert: function(userId, doc) { return true; },                                                                       // 228\n update: function(userId, doc, fields, modifier) { return true; },                                                     // 229\n remove: function(userId, doc) { return true; },                                                                       // 230\n download: function(userId, fileObj) { return true; },                                                                 // 231\n });                                                                                                                   // 232\n ```                                                                                                                   // 233\n */                                                                                                                    // 234\nFS.Collection.prototype.deny = function(options) {                                                                     // 235\n  var self = this;                                                                                                     // 236\n                                                                                                                       // 237\n  // Pull out the custom \"download\" functions                                                                          // 238\n  if (options.download) {                                                                                              // 239\n    if (!(options.download instanceof Function)) {                                                                     // 240\n      throw new Error(\"deny: Value for `download` must be a function\");                                                // 241\n    }                                                                                                                  // 242\n    self._validators.download.deny.push(options.download);                                                             // 243\n    delete options.download;                                                                                           // 244\n  }                                                                                                                    // 245\n                                                                                                                       // 246\n  return self.files.deny.call(self.files, options);                                                                    // 247\n};                                                                                                                     // 248\n                                                                                                                       // 249\n// TODO: Upsert?                                                                                                       // 250\n                                                                                                                       // 251\n/**                                                                                                                    // 252\n * We provide a default implementation that doesn't do anything.                                                       // 253\n * Can be changed by user or packages, such as the default cfs-collection-filters pkg.                                 // 254\n * @param  {FS.File} fileObj File object                                                                               // 255\n * @return {Boolean} Should we allow insertion of this file?                                                           // 256\n */                                                                                                                    // 257\nFS.Collection.prototype.allowsFile = function fsColAllowsFile(fileObj) {                                               // 258\n  return true;                                                                                                         // 259\n};                                                                                                                     // 260\n                                                                                                                       // 261\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}