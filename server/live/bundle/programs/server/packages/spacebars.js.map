{"version":3,"sources":["meteor://ðŸ’»app/packages/spacebars/packages/spacebars.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8F","file":"/packages/spacebars.js","sourcesContent":["(function(){\n\n///////////////////////////////////////////////////////////////////////////////////\n//                                                                               //\n// packages/spacebars/spacebars-runtime.js                                       //\n//                                                                               //\n///////////////////////////////////////////////////////////////////////////////////\n                                                                                 //\nSpacebars = {};                                                                  // 1\n                                                                                 // 2\nvar tripleEquals = function (a, b) { return a === b; };                          // 3\n                                                                                 // 4\nSpacebars.include = function (templateOrFunction, contentFunc, elseFunc) {       // 5\n  if (! templateOrFunction)                                                      // 6\n    return null;                                                                 // 7\n                                                                                 // 8\n  if (typeof templateOrFunction !== 'function') {                                // 9\n    var template = templateOrFunction;                                           // 10\n    if (! Blaze.isTemplate(template))                                            // 11\n      throw new Error(\"Expected template or null, found: \" + template);          // 12\n    var view = templateOrFunction.constructView(contentFunc, elseFunc);          // 13\n    view.__startsNewLexicalScope = true;                                         // 14\n    return view;                                                                 // 15\n  }                                                                              // 16\n                                                                                 // 17\n  var templateVar = Blaze.ReactiveVar(null, tripleEquals);                       // 18\n  var view = Blaze.View('Spacebars.include', function () {                       // 19\n    var template = templateVar.get();                                            // 20\n    if (template === null)                                                       // 21\n      return null;                                                               // 22\n                                                                                 // 23\n    if (! Blaze.isTemplate(template))                                            // 24\n      throw new Error(\"Expected template or null, found: \" + template);          // 25\n                                                                                 // 26\n    return template.constructView(contentFunc, elseFunc);                        // 27\n  });                                                                            // 28\n  view.__templateVar = templateVar;                                              // 29\n  view.onViewCreated(function () {                                               // 30\n    this.autorun(function () {                                                   // 31\n      templateVar.set(templateOrFunction());                                     // 32\n    });                                                                          // 33\n  });                                                                            // 34\n  view.__startsNewLexicalScope = true;                                           // 35\n                                                                                 // 36\n  return view;                                                                   // 37\n};                                                                               // 38\n                                                                                 // 39\n// Executes `{{foo bar baz}}` when called on `(foo, bar, baz)`.                  // 40\n// If `bar` and `baz` are functions, they are called before                      // 41\n// `foo` is called on them.                                                      // 42\n//                                                                               // 43\n// This is the shared part of Spacebars.mustache and                             // 44\n// Spacebars.attrMustache, which differ in how they post-process the             // 45\n// result.                                                                       // 46\nSpacebars.mustacheImpl = function (value/*, args*/) {                            // 47\n  var args = arguments;                                                          // 48\n  // if we have any arguments (pos or kw), add an options argument               // 49\n  // if there isn't one.                                                         // 50\n  if (args.length > 1) {                                                         // 51\n    var kw = args[args.length - 1];                                              // 52\n    if (! (kw instanceof Spacebars.kw)) {                                        // 53\n      kw = Spacebars.kw();                                                       // 54\n      // clone arguments into an actual array, then push                         // 55\n      // the empty kw object.                                                    // 56\n      args = Array.prototype.slice.call(arguments);                              // 57\n      args.push(kw);                                                             // 58\n    } else {                                                                     // 59\n      // For each keyword arg, call it if it's a function                        // 60\n      var newHash = {};                                                          // 61\n      for (var k in kw.hash) {                                                   // 62\n        var v = kw.hash[k];                                                      // 63\n        newHash[k] = (typeof v === 'function' ? v() : v);                        // 64\n      }                                                                          // 65\n      args[args.length - 1] = Spacebars.kw(newHash);                             // 66\n    }                                                                            // 67\n  }                                                                              // 68\n                                                                                 // 69\n  return Spacebars.call.apply(null, args);                                       // 70\n};                                                                               // 71\n                                                                                 // 72\nSpacebars.mustache = function (value/*, args*/) {                                // 73\n  var result = Spacebars.mustacheImpl.apply(null, arguments);                    // 74\n                                                                                 // 75\n  if (result instanceof Spacebars.SafeString)                                    // 76\n    return HTML.Raw(result.toString());                                          // 77\n  else                                                                           // 78\n    // map `null`, `undefined`, and `false` to null, which is important          // 79\n    // so that attributes with nully values are considered absent.               // 80\n    // stringify anything else (e.g. strings, booleans, numbers including 0).    // 81\n    return (result == null || result === false) ? null : String(result);         // 82\n};                                                                               // 83\n                                                                                 // 84\nSpacebars.attrMustache = function (value/*, args*/) {                            // 85\n  var result = Spacebars.mustacheImpl.apply(null, arguments);                    // 86\n                                                                                 // 87\n  if (result == null || result === '') {                                         // 88\n    return null;                                                                 // 89\n  } else if (typeof result === 'object') {                                       // 90\n    return result;                                                               // 91\n  } else if (typeof result === 'string' && HTML.isValidAttributeName(result)) {  // 92\n    var obj = {};                                                                // 93\n    obj[result] = '';                                                            // 94\n    return obj;                                                                  // 95\n  } else {                                                                       // 96\n    throw new Error(\"Expected valid attribute name, '', null, or object\");       // 97\n  }                                                                              // 98\n};                                                                               // 99\n                                                                                 // 100\nSpacebars.dataMustache = function (value/*, args*/) {                            // 101\n  var result = Spacebars.mustacheImpl.apply(null, arguments);                    // 102\n                                                                                 // 103\n  return result;                                                                 // 104\n};                                                                               // 105\n                                                                                 // 106\n// Idempotently wrap in `HTML.Raw`.                                              // 107\n//                                                                               // 108\n// Called on the return value from `Spacebars.mustache` in case the              // 109\n// template uses triple-stache (`{{{foo bar baz}}}`).                            // 110\nSpacebars.makeRaw = function (value) {                                           // 111\n  if (value == null) // null or undefined                                        // 112\n    return null;                                                                 // 113\n  else if (value instanceof HTML.Raw)                                            // 114\n    return value;                                                                // 115\n  else                                                                           // 116\n    return HTML.Raw(value);                                                      // 117\n};                                                                               // 118\n                                                                                 // 119\n// If `value` is a function, called it on the `args`, after                      // 120\n// evaluating the args themselves (by calling them if they are                   // 121\n// functions).  Otherwise, simply return `value` (and assert that                // 122\n// there are no args).                                                           // 123\nSpacebars.call = function (value/*, args*/) {                                    // 124\n  if (typeof value === 'function') {                                             // 125\n    // evaluate arguments if they are functions (by calling them)                // 126\n    var newArgs = [];                                                            // 127\n    for (var i = 1; i < arguments.length; i++) {                                 // 128\n      var arg = arguments[i];                                                    // 129\n      newArgs[i-1] = (typeof arg === 'function' ? arg() : arg);                  // 130\n    }                                                                            // 131\n                                                                                 // 132\n    return value.apply(null, newArgs);                                           // 133\n  } else {                                                                       // 134\n    if (arguments.length > 1)                                                    // 135\n      throw new Error(\"Can't call non-function: \" + value);                      // 136\n                                                                                 // 137\n    return value;                                                                // 138\n  }                                                                              // 139\n};                                                                               // 140\n                                                                                 // 141\n// Call this as `Spacebars.kw({ ... })`.  The return value                       // 142\n// is `instanceof Spacebars.kw`.                                                 // 143\nSpacebars.kw = function (hash) {                                                 // 144\n  if (! (this instanceof Spacebars.kw))                                          // 145\n    // called without new; call with new                                         // 146\n    return new Spacebars.kw(hash);                                               // 147\n                                                                                 // 148\n  this.hash = hash || {};                                                        // 149\n};                                                                               // 150\n                                                                                 // 151\n// Call this as `Spacebars.SafeString(\"some HTML\")`.  The return value           // 152\n// is `instanceof Spacebars.SafeString` (and `instanceof Handlebars.SafeString).\nSpacebars.SafeString = function (html) {                                         // 154\n  if (! (this instanceof Spacebars.SafeString))                                  // 155\n    // called without new; call with new                                         // 156\n    return new Spacebars.SafeString(html);                                       // 157\n                                                                                 // 158\n  return new Handlebars.SafeString(html);                                        // 159\n};                                                                               // 160\nSpacebars.SafeString.prototype = Handlebars.SafeString.prototype;                // 161\n                                                                                 // 162\n// `Spacebars.dot(foo, \"bar\", \"baz\")` performs a special kind                    // 163\n// of `foo.bar.baz` that allows safe indexing of `null` and                      // 164\n// indexing of functions (which calls the function).  If the                     // 165\n// result is a function, it is always a bound function (e.g.                     // 166\n// a wrapped version of `baz` that always uses `foo.bar` as                      // 167\n// `this`).                                                                      // 168\n//                                                                               // 169\n// In `Spacebars.dot(foo, \"bar\")`, `foo` is assumed to be either                 // 170\n// a non-function value or a \"fully-bound\" function wrapping a value,            // 171\n// where fully-bound means it takes no arguments and ignores `this`.             // 172\n//                                                                               // 173\n// `Spacebars.dot(foo, \"bar\")` performs the following steps:                     // 174\n//                                                                               // 175\n// * If `foo` is falsy, return `foo`.                                            // 176\n//                                                                               // 177\n// * If `foo` is a function, call it (set `foo` to `foo()`).                     // 178\n//                                                                               // 179\n// * If `foo` is falsy now, return `foo`.                                        // 180\n//                                                                               // 181\n// * Return `foo.bar`, binding it to `foo` if it's a function.                   // 182\nSpacebars.dot = function (value, id1/*, id2, ...*/) {                            // 183\n  if (arguments.length > 2) {                                                    // 184\n    // Note: doing this recursively is probably less efficient than              // 185\n    // doing it in an iterative loop.                                            // 186\n    var argsForRecurse = [];                                                     // 187\n    argsForRecurse.push(Spacebars.dot(value, id1));                              // 188\n    argsForRecurse.push.apply(argsForRecurse,                                    // 189\n                              Array.prototype.slice.call(arguments, 2));         // 190\n    return Spacebars.dot.apply(null, argsForRecurse);                            // 191\n  }                                                                              // 192\n                                                                                 // 193\n  if (typeof value === 'function')                                               // 194\n    value = value();                                                             // 195\n                                                                                 // 196\n  if (! value)                                                                   // 197\n    return value; // falsy, don't index, pass through                            // 198\n                                                                                 // 199\n  var result = value[id1];                                                       // 200\n  if (typeof result !== 'function')                                              // 201\n    return result;                                                               // 202\n  // `value[id1]` (or `value()[id1]`) is a function.                             // 203\n  // Bind it so that when called, `value` will be placed in `this`.              // 204\n  return function (/*arguments*/) {                                              // 205\n    return result.apply(value, arguments);                                       // 206\n  };                                                                             // 207\n};                                                                               // 208\n                                                                                 // 209\n// Spacebars.With implements the conditional logic of rendering                  // 210\n// the `{{else}}` block if the argument is falsy.  It combines                   // 211\n// a Blaze.If with a Blaze.With (the latter only in the truthy                   // 212\n// case, since the else block is evaluated without entering                      // 213\n// a new data context).                                                          // 214\nSpacebars.With = function (argFunc, contentFunc, elseFunc) {                     // 215\n  var argVar = new Blaze.ReactiveVar;                                            // 216\n  var view = Blaze.View('Spacebars_with', function () {                          // 217\n    return Blaze.If(function () { return argVar.get(); },                        // 218\n                    function () { return Blaze.With(function () {                // 219\n                      return argVar.get(); }, contentFunc); },                   // 220\n                    elseFunc);                                                   // 221\n  });                                                                            // 222\n  view.onViewCreated(function () {                                               // 223\n    this.autorun(function () {                                                   // 224\n      argVar.set(argFunc());                                                     // 225\n                                                                                 // 226\n      // This is a hack so that autoruns inside the body                         // 227\n      // of the #with get stopped sooner.  It reaches inside                     // 228\n      // our ReactiveVar to access its dep.                                      // 229\n                                                                                 // 230\n      Tracker.onInvalidate(function () {                                         // 231\n        argVar.dep.changed();                                                    // 232\n      });                                                                        // 233\n                                                                                 // 234\n      // Take the case of `{{#with A}}{{B}}{{/with}}`.  The goal                 // 235\n      // is to not re-render `B` if `A` changes to become falsy                  // 236\n      // and `B` is simultaneously invalidated.                                  // 237\n      //                                                                         // 238\n      // A series of autoruns are involved:                                      // 239\n      //                                                                         // 240\n      // 1. This autorun (argument to Spacebars.With)                            // 241\n      // 2. Argument to Blaze.If                                                 // 242\n      // 3. Blaze.If view re-render                                              // 243\n      // 4. Argument to Blaze.With                                               // 244\n      // 5. The template tag `{{B}}`                                             // 245\n      //                                                                         // 246\n      // When (3) is invalidated, it immediately stops (4) and (5)               // 247\n      // because of a Tracker.onInvalidate built into materializeView.           // 248\n      // (When a View's render method is invalidated, it immediately             // 249\n      // tears down all the subviews, via a Tracker.onInvalidate much            // 250\n      // like this one.                                                          // 251\n      //                                                                         // 252\n      // Suppose `A` changes to become falsy, and `B` changes at the             // 253\n      // same time (i.e. without an intervening flush).                          // 254\n      // Without the code above, this happens:                                   // 255\n      //                                                                         // 256\n      // - (1) and (5) are invalidated.                                          // 257\n      // - (1) runs, invalidating (2) and (4).                                   // 258\n      // - (5) runs.                                                             // 259\n      // - (2) runs, invalidating (3), stopping (4) and (5).                     // 260\n      //                                                                         // 261\n      // With the code above:                                                    // 262\n      //                                                                         // 263\n      // - (1) and (5) are invalidated, invalidating (2) and (4).                // 264\n      // - (1) runs.                                                             // 265\n      // - (2) runs, invalidating (3), stopping (4) and (5).                     // 266\n      //                                                                         // 267\n      // If the re-run of (5) is originally enqueued before (1), all             // 268\n      // bets are off, but typically that doesn't seem to be the                 // 269\n      // case.  Anyway, doing this is always better than not doing it,           // 270\n      // because it might save a bunch of DOM from being updated                 // 271\n      // needlessly.                                                             // 272\n    });                                                                          // 273\n  });                                                                            // 274\n                                                                                 // 275\n  return view;                                                                   // 276\n};                                                                               // 277\n                                                                                 // 278\n// XXX COMPAT WITH 0.9.0                                                         // 279\nSpacebars.TemplateWith = Blaze._TemplateWith;                                    // 280\n                                                                                 // 281\n///////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}