{"version":3,"sources":["meteor://ðŸ’»app/packages/cfs_file/packages/cfs_file.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4E","file":"/packages/cfs_file.js","sourcesContent":["(function () {\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/cfs:file/fsFile-common.js                                                                                 //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n/**                                                                                                                   // 1\n * @method FS.File                                                                                                    // 2\n * @namespace FS.File                                                                                                 // 3\n * @public                                                                                                            // 4\n * @constructor                                                                                                       // 5\n * @param {object|FS.File|data to attach} [ref] Another FS.File instance, a filerecord, or some data to pass to attachData\n */                                                                                                                   // 7\nFS.File = function(ref, createdByTransform) {                                                                         // 8\n  var self = this;                                                                                                    // 9\n                                                                                                                      // 10\n  self.createdByTransform = !!createdByTransform;                                                                     // 11\n                                                                                                                      // 12\n  if (ref instanceof FS.File || isBasicObject(ref)) {                                                                 // 13\n    // Extend self with filerecord related data                                                                       // 14\n    FS.Utility.extend(self, FS.Utility.cloneFileRecord(ref, {full: true}));                                           // 15\n  } else if (ref) {                                                                                                   // 16\n    self.attachData(ref);                                                                                             // 17\n  }                                                                                                                   // 18\n};                                                                                                                    // 19\n                                                                                                                      // 20\n// An FS.File can emit events                                                                                         // 21\nFS.File.prototype = new EventEmitter();                                                                               // 22\n                                                                                                                      // 23\n/**                                                                                                                   // 24\n * @method FS.File.prototype.attachData                                                                               // 25\n * @public                                                                                                            // 26\n * @param {File|Blob|Buffer|ArrayBuffer|Uint8Array|String} data The data that you want to attach to the file.         // 27\n * @param {Object} [options] Options                                                                                  // 28\n * @param {String} [options.type] The data content (MIME) type, if known.                                             // 29\n * @param {String} [options.headers] When attaching a URL, headers to be used for the GET request (currently server only)\n * @param {String} [options.auth] When attaching a URL, \"username:password\" to be used for the GET request (currently server only)\n * @param {Function} [callback] Callback function, callback(error). On the client, a callback is required if data is a URL.\n * @returns {FS.File} This FS.File instance.                                                                          // 33\n *                                                                                                                    // 34\n */                                                                                                                   // 35\nFS.File.prototype.attachData = function fsFileAttachData(data, options, callback) {                                   // 36\n  var self = this;                                                                                                    // 37\n                                                                                                                      // 38\n  if (!callback && typeof options === \"function\") {                                                                   // 39\n    callback = options;                                                                                               // 40\n    options = {};                                                                                                     // 41\n  }                                                                                                                   // 42\n  options = options || {};                                                                                            // 43\n                                                                                                                      // 44\n  if (!data) {                                                                                                        // 45\n    throw new Error('FS.File.attachData requires a data argument with some data');                                    // 46\n  }                                                                                                                   // 47\n                                                                                                                      // 48\n  var urlOpts;                                                                                                        // 49\n                                                                                                                      // 50\n  // Set any other properties we can determine from the source data                                                   // 51\n  // File                                                                                                             // 52\n  if (typeof File !== \"undefined\" && data instanceof File) {                                                          // 53\n    self.name(data.name);                                                                                             // 54\n    self.updatedAt(data.lastModifiedDate);                                                                            // 55\n    self.size(data.size);                                                                                             // 56\n    setData(data.type);                                                                                               // 57\n  }                                                                                                                   // 58\n  // Blob                                                                                                             // 59\n  else if (typeof Blob !== \"undefined\" && data instanceof Blob) {                                                     // 60\n    self.updatedAt(new Date());                                                                                       // 61\n    self.size(data.size);                                                                                             // 62\n    setData(data.type);                                                                                               // 63\n  }                                                                                                                   // 64\n  // URL: we need to do a HEAD request to get the type because type                                                   // 65\n  // is required for filtering to work.                                                                               // 66\n  else if (typeof data === \"string\" && (data.slice(0, 5) === \"http:\" || data.slice(0, 6) === \"https:\")) {             // 67\n    urlOpts = FS.Utility.extend({}, options);                                                                         // 68\n    if (urlOpts.type) {                                                                                               // 69\n      delete urlOpts.type;                                                                                            // 70\n    }                                                                                                                 // 71\n                                                                                                                      // 72\n    if (!callback) {                                                                                                  // 73\n      if (Meteor.isClient) {                                                                                          // 74\n        throw new Error('FS.File.attachData requires a callback when attaching a URL on the client');                 // 75\n      }                                                                                                               // 76\n      var result = Meteor.call('_cfs_getUrlInfo', data, urlOpts);                                                     // 77\n      FS.Utility.extend(self, {original: result});                                                                    // 78\n      setData(result.type);                                                                                           // 79\n    } else {                                                                                                          // 80\n      Meteor.call('_cfs_getUrlInfo', data, urlOpts, function (error, result) {                                        // 81\n        FS.debug && console.log(\"URL HEAD RESULT:\", result);                                                          // 82\n        if (error) {                                                                                                  // 83\n          callback(error);                                                                                            // 84\n        } else {                                                                                                      // 85\n          FS.Utility.extend(self, {original: result});                                                                // 86\n          setData(result.type);                                                                                       // 87\n        }                                                                                                             // 88\n      });                                                                                                             // 89\n    }                                                                                                                 // 90\n  }                                                                                                                   // 91\n  // Everything else                                                                                                  // 92\n  else {                                                                                                              // 93\n    setData(options.type);                                                                                            // 94\n  }                                                                                                                   // 95\n                                                                                                                      // 96\n  // Set the data                                                                                                     // 97\n  function setData(type) {                                                                                            // 98\n    self.data = new DataMan(data, type, urlOpts);                                                                     // 99\n                                                                                                                      // 100\n    // Update the type to match what the data is                                                                      // 101\n    self.type(self.data.type());                                                                                      // 102\n                                                                                                                      // 103\n    // Update the size to match what the data is.                                                                     // 104\n    // It's always safe to call self.data.size() without supplying a callback                                         // 105\n    // because it requires a callback only for URLs on the client, and we                                             // 106\n    // already added size for URLs when we got the result from '_cfs_getUrlInfo' method.                              // 107\n    if (!self.size()) {                                                                                               // 108\n      if (callback) {                                                                                                 // 109\n        self.data.size(function (error, size) {                                                                       // 110\n          if (error) {                                                                                                // 111\n            callback && callback(error);                                                                              // 112\n          } else {                                                                                                    // 113\n            self.size(size);                                                                                          // 114\n            setName();                                                                                                // 115\n          }                                                                                                           // 116\n        });                                                                                                           // 117\n      } else {                                                                                                        // 118\n        self.size(self.data.size());                                                                                  // 119\n        setName();                                                                                                    // 120\n      }                                                                                                               // 121\n    } else {                                                                                                          // 122\n      setName();                                                                                                      // 123\n    }                                                                                                                 // 124\n  }                                                                                                                   // 125\n                                                                                                                      // 126\n  function setName() {                                                                                                // 127\n    // See if we can extract a file name from URL or filepath                                                         // 128\n    if (!self.name() && typeof data === \"string\") {                                                                   // 129\n      // name from URL                                                                                                // 130\n      if (data.slice(0, 5) === \"http:\" || data.slice(0, 6) === \"https:\") {                                            // 131\n        if (FS.Utility.getFileExtension(data).length) {                                                               // 132\n          // for a URL we assume the end is a filename only if it has an extension                                    // 133\n          self.name(FS.Utility.getFileName(data));                                                                    // 134\n        }                                                                                                             // 135\n      }                                                                                                               // 136\n      // name from filepath                                                                                           // 137\n      else if (data.slice(0, 5) !== \"data:\") {                                                                        // 138\n        self.name(FS.Utility.getFileName(data));                                                                      // 139\n      }                                                                                                               // 140\n    }                                                                                                                 // 141\n                                                                                                                      // 142\n    callback && callback();                                                                                           // 143\n  }                                                                                                                   // 144\n                                                                                                                      // 145\n  return self; //allow chaining                                                                                       // 146\n};                                                                                                                    // 147\n                                                                                                                      // 148\n/**                                                                                                                   // 149\n * @method FS.File.prototype.uploadProgress                                                                           // 150\n * @public                                                                                                            // 151\n * @returns {number} The server confirmed upload progress                                                             // 152\n */                                                                                                                   // 153\nFS.File.prototype.uploadProgress = function() {                                                                       // 154\n  var self = this;                                                                                                    // 155\n  // Make sure our file record is updated                                                                             // 156\n  self.getFileRecord();                                                                                               // 157\n                                                                                                                      // 158\n  // If fully uploaded, return 100                                                                                    // 159\n  if (self.uploadedAt) {                                                                                              // 160\n    return 100;                                                                                                       // 161\n  }                                                                                                                   // 162\n  // Otherwise return the confirmed progress or 0                                                                     // 163\n  else {                                                                                                              // 164\n    return Math.round((self.chunkCount || 0) / (self.chunkSum || 1) * 100);                                           // 165\n  }                                                                                                                   // 166\n};                                                                                                                    // 167\n                                                                                                                      // 168\n/**                                                                                                                   // 169\n * @method FS.File.prototype.controlledByDeps                                                                         // 170\n * @public                                                                                                            // 171\n * @returns {FS.Collection} Returns true if this FS.File is reactive                                                  // 172\n *                                                                                                                    // 173\n * > Note: Returns true if this FS.File object was created by a FS.Collection                                         // 174\n * > and we are in a reactive computations. What does this mean? Well it should                                       // 175\n * > mean that our fileRecord is fully updated by Meteor and we are mounted on                                        // 176\n * > a collection                                                                                                     // 177\n */                                                                                                                   // 178\nFS.File.prototype.controlledByDeps = function() {                                                                     // 179\n  var self = this;                                                                                                    // 180\n  return self.createdByTransform && Deps.active;                                                                      // 181\n};                                                                                                                    // 182\n                                                                                                                      // 183\n/**                                                                                                                   // 184\n * @method FS.File.prototype.getCollection                                                                            // 185\n * @public                                                                                                            // 186\n * @returns {FS.Collection} Returns attached collection or undefined if not mounted                                   // 187\n */                                                                                                                   // 188\nFS.File.prototype.getCollection = function() {                                                                        // 189\n  // Get the collection reference                                                                                     // 190\n  var self = this;                                                                                                    // 191\n                                                                                                                      // 192\n  // If we already made the link then do no more                                                                      // 193\n  if (self.collection) {                                                                                              // 194\n    return self.collection;                                                                                           // 195\n  }                                                                                                                   // 196\n                                                                                                                      // 197\n  // If we don't have a collectionName then there's not much to do, the file is                                       // 198\n  // not mounted yet                                                                                                  // 199\n  if (!self.collectionName) {                                                                                         // 200\n    // Should not throw an error here - could be common that the file is not                                          // 201\n    // yet mounted into a collection                                                                                  // 202\n    return;                                                                                                           // 203\n  }                                                                                                                   // 204\n                                                                                                                      // 205\n  // Link the collection to the file                                                                                  // 206\n  self.collection = FS._collections[self.collectionName];                                                             // 207\n                                                                                                                      // 208\n  return self.collection; //possibly undefined, but that's desired behavior                                           // 209\n};                                                                                                                    // 210\n                                                                                                                      // 211\n/**                                                                                                                   // 212\n * @method FS.File.prototype.isMounted                                                                                // 213\n * @public                                                                                                            // 214\n * @returns {FS.Collection} Returns attached collection or undefined if not mounted                                   // 215\n */                                                                                                                   // 216\nFS.File.prototype.isMounted = FS.File.prototype.getCollection;                                                        // 217\n                                                                                                                      // 218\n/**                                                                                                                   // 219\n * @method FS.File.prototype.getFileRecord Returns the fileRecord                                                     // 220\n * @public                                                                                                            // 221\n * @returns {object} The filerecord                                                                                   // 222\n */                                                                                                                   // 223\nFS.File.prototype.getFileRecord = function() {                                                                        // 224\n  var self = this;                                                                                                    // 225\n  // Check if this file object fileRecord is kept updated by Meteor, if so                                            // 226\n  // return self                                                                                                      // 227\n  if (self.controlledByDeps()) {                                                                                      // 228\n    return self;                                                                                                      // 229\n  }                                                                                                                   // 230\n  // Go for manually updating the file record                                                                         // 231\n  if (self.isMounted()) {                                                                                             // 232\n    FS.debug && console.log('GET FILERECORD: ' + self._id);                                                           // 233\n                                                                                                                      // 234\n    // Return the fileRecord or an empty object                                                                       // 235\n    var fileRecord = self.collection.files.findOne({_id: self._id}) || {};                                            // 236\n    FS.Utility.extend(self, fileRecord);                                                                              // 237\n    return fileRecord;                                                                                                // 238\n  } else {                                                                                                            // 239\n    // We return an empty object, this way users can still do `getRecord().size`                                      // 240\n    // Without getting an error                                                                                       // 241\n    return {};                                                                                                        // 242\n  }                                                                                                                   // 243\n};                                                                                                                    // 244\n                                                                                                                      // 245\n/**                                                                                                                   // 246\n * @method FS.File.prototype.update                                                                                   // 247\n * @public                                                                                                            // 248\n * @param {modifier} modifier                                                                                         // 249\n * @param {object} [options]                                                                                          // 250\n * @param {function} [callback]                                                                                       // 251\n *                                                                                                                    // 252\n * Updates the fileRecord.                                                                                            // 253\n */                                                                                                                   // 254\nFS.File.prototype.update = function(modifier, options, callback) {                                                    // 255\n  var self = this;                                                                                                    // 256\n                                                                                                                      // 257\n  FS.debug && console.log('UPDATE: ' + JSON.stringify(modifier));                                                     // 258\n                                                                                                                      // 259\n  // Make sure we have options and callback                                                                           // 260\n  if (!callback && typeof options === 'function') {                                                                   // 261\n    callback = options;                                                                                               // 262\n    options = {};                                                                                                     // 263\n  }                                                                                                                   // 264\n  callback = callback || FS.Utility.defaultCallback;                                                                  // 265\n                                                                                                                      // 266\n  if (!self.isMounted()) {                                                                                            // 267\n    callback(new Error(\"Cannot update a file that is not associated with a collection\"));                             // 268\n    return;                                                                                                           // 269\n  }                                                                                                                   // 270\n                                                                                                                      // 271\n  // Call collection update - File record                                                                             // 272\n  return self.collection.files.update({_id: self._id}, modifier, options, function(err, count) {                      // 273\n    // Update the fileRecord if it was changed and on the client                                                      // 274\n    // The server-side methods will pull the fileRecord if needed                                                     // 275\n    if (count > 0 && Meteor.isClient)                                                                                 // 276\n      self.getFileRecord();                                                                                           // 277\n    // Call callback                                                                                                  // 278\n    callback(err, count);                                                                                             // 279\n  });                                                                                                                 // 280\n};                                                                                                                    // 281\n                                                                                                                      // 282\n/**                                                                                                                   // 283\n * @method FS.File.prototype._saveChanges                                                                             // 284\n * @private                                                                                                           // 285\n * @param {String} [what] \"_original\" to save original info, or a store name to save info for that store, or saves everything\n *                                                                                                                    // 287\n * Updates the fileRecord from values currently set on the FS.File instance.                                          // 288\n */                                                                                                                   // 289\nFS.File.prototype._saveChanges = function(what) {                                                                     // 290\n  var self = this;                                                                                                    // 291\n                                                                                                                      // 292\n  if (!self.isMounted()) {                                                                                            // 293\n    return;                                                                                                           // 294\n  }                                                                                                                   // 295\n                                                                                                                      // 296\n  FS.debug && console.log(\"FS.File._saveChanges:\", what || \"all\");                                                    // 297\n                                                                                                                      // 298\n  var mod = {$set: {}};                                                                                               // 299\n  if (what === \"_original\") {                                                                                         // 300\n    mod.$set.original = self.original;                                                                                // 301\n  } else if (typeof what === \"string\") {                                                                              // 302\n    var info = self.copies[what];                                                                                     // 303\n    if (info) {                                                                                                       // 304\n      mod.$set[\"copies.\" + what] = info;                                                                              // 305\n    }                                                                                                                 // 306\n  } else {                                                                                                            // 307\n    mod.$set.original = self.original;                                                                                // 308\n    mod.$set.copies = self.copies;                                                                                    // 309\n  }                                                                                                                   // 310\n                                                                                                                      // 311\n  self.update(mod);                                                                                                   // 312\n};                                                                                                                    // 313\n                                                                                                                      // 314\n/**                                                                                                                   // 315\n * @method FS.File.prototype.remove                                                                                   // 316\n * @public                                                                                                            // 317\n * @param {Function} [callback]                                                                                       // 318\n * @returns {number} Count                                                                                            // 319\n *                                                                                                                    // 320\n * Remove the current file from its FS.Collection                                                                     // 321\n */                                                                                                                   // 322\nFS.File.prototype.remove = function(callback) {                                                                       // 323\n  var self = this;                                                                                                    // 324\n                                                                                                                      // 325\n  FS.debug && console.log('REMOVE: ' + self._id);                                                                     // 326\n                                                                                                                      // 327\n  callback = callback || FS.Utility.defaultCallback;                                                                  // 328\n                                                                                                                      // 329\n  if (!self.isMounted()) {                                                                                            // 330\n    callback(new Error(\"Cannot remove a file that is not associated with a collection\"));                             // 331\n    return;                                                                                                           // 332\n  }                                                                                                                   // 333\n                                                                                                                      // 334\n  return self.collection.files.remove({_id: self._id}, function(err, res) {                                           // 335\n    if (!err) {                                                                                                       // 336\n      delete self._id;                                                                                                // 337\n      delete self.collection;                                                                                         // 338\n      delete self.collectionName;                                                                                     // 339\n    }                                                                                                                 // 340\n    callback(err, res);                                                                                               // 341\n  });                                                                                                                 // 342\n};                                                                                                                    // 343\n                                                                                                                      // 344\n/**                                                                                                                   // 345\n * @method FS.File.prototype.moveTo                                                                                   // 346\n * @param {FS.Collection} targetCollection                                                                            // 347\n * @private // Marked private until implemented                                                                       // 348\n * @todo Needs to be implemented                                                                                      // 349\n *                                                                                                                    // 350\n * Move the file from current collection to another collection                                                        // 351\n *                                                                                                                    // 352\n * > Note: Not yet implemented                                                                                        // 353\n */                                                                                                                   // 354\n                                                                                                                      // 355\n/**                                                                                                                   // 356\n * @method FS.File.prototype.getExtension Returns the lowercase file extension                                        // 357\n * @public                                                                                                            // 358\n * @deprecated Use the `extension` getter/setter method instead.                                                      // 359\n * @param {Object} [options]                                                                                          // 360\n * @param {String} [options.store] - Store name. Default is the original extension.                                   // 361\n * @returns {string} The extension eg.: `jpg` or if not found then an empty string ''                                 // 362\n */                                                                                                                   // 363\nFS.File.prototype.getExtension = function(options) {                                                                  // 364\n  var self = this;                                                                                                    // 365\n  return self.extension(options);                                                                                     // 366\n};                                                                                                                    // 367\n                                                                                                                      // 368\nfunction checkContentType(fsFile, storeName, startOfType) {                                                           // 369\n  var type;                                                                                                           // 370\n  if (storeName && fsFile.hasStored(storeName)) {                                                                     // 371\n    type = fsFile.type({store: storeName});                                                                           // 372\n  } else {                                                                                                            // 373\n    type = fsFile.type();                                                                                             // 374\n  }                                                                                                                   // 375\n  if (typeof type === \"string\") {                                                                                     // 376\n    return type.indexOf(startOfType) === 0;                                                                           // 377\n  }                                                                                                                   // 378\n  return false;                                                                                                       // 379\n}                                                                                                                     // 380\n                                                                                                                      // 381\n/**                                                                                                                   // 382\n * @method FS.File.prototype.isImage Is it an image file?                                                             // 383\n * @public                                                                                                            // 384\n * @param {object} [options]                                                                                          // 385\n * @param {string} [options.store] The store we're interested in                                                      // 386\n *                                                                                                                    // 387\n * Returns true if the copy of this file in the specified store has an image                                          // 388\n * content type. If the file object is unmounted or doesn't have a copy for                                           // 389\n * the specified store, or if you don't specify a store, this method checks                                           // 390\n * the content type of the original file.                                                                             // 391\n */                                                                                                                   // 392\nFS.File.prototype.isImage = function(options) {                                                                       // 393\n  return checkContentType(this, (options || {}).store, 'image/');                                                     // 394\n};                                                                                                                    // 395\n                                                                                                                      // 396\n/**                                                                                                                   // 397\n * @method FS.File.prototype.isVideo Is it a video file?                                                              // 398\n * @public                                                                                                            // 399\n * @param {object} [options]                                                                                          // 400\n * @param {string} [options.store] The store we're interested in                                                      // 401\n *                                                                                                                    // 402\n * Returns true if the copy of this file in the specified store has a video                                           // 403\n * content type. If the file object is unmounted or doesn't have a copy for                                           // 404\n * the specified store, or if you don't specify a store, this method checks                                           // 405\n * the content type of the original file.                                                                             // 406\n */                                                                                                                   // 407\nFS.File.prototype.isVideo = function(options) {                                                                       // 408\n  return checkContentType(this, (options || {}).store, 'video/');                                                     // 409\n};                                                                                                                    // 410\n                                                                                                                      // 411\n/**                                                                                                                   // 412\n * @method FS.File.prototype.isAudio Is it an audio file?                                                             // 413\n * @public                                                                                                            // 414\n * @param {object} [options]                                                                                          // 415\n * @param {string} [options.store] The store we're interested in                                                      // 416\n *                                                                                                                    // 417\n * Returns true if the copy of this file in the specified store has an audio                                          // 418\n * content type. If the file object is unmounted or doesn't have a copy for                                           // 419\n * the specified store, or if you don't specify a store, this method checks                                           // 420\n * the content type of the original file.                                                                             // 421\n */                                                                                                                   // 422\nFS.File.prototype.isAudio = function(options) {                                                                       // 423\n  return checkContentType(this, (options || {}).store, 'audio/');                                                     // 424\n};                                                                                                                    // 425\n                                                                                                                      // 426\n/**                                                                                                                   // 427\n * @method FS.File.prototype.formattedSize                                                                            // 428\n * @public                                                                                                            // 429\n * @param  {Object} options                                                                                           // 430\n * @param  {String} [options.store=none,display original file size] Which file do you want to get the size of?        // 431\n * @param  {String} [options.formatString='0.00 b'] The `numeral` format string to use.                               // 432\n * @return {String} The file size formatted as a human readable string and reactively updated.                        // 433\n *                                                                                                                    // 434\n * * You must add the `numeral` package to your app before you can use this method.                                   // 435\n * * If info is not found or a size can't be determined, it will show 0.                                              // 436\n */                                                                                                                   // 437\nFS.File.prototype.formattedSize = function fsFileFormattedSize(options) {                                             // 438\n  var self = this;                                                                                                    // 439\n                                                                                                                      // 440\n  if (typeof numeral !== \"function\")                                                                                  // 441\n    throw new Error(\"You must add the numeral package if you call FS.File.formattedSize\");                            // 442\n                                                                                                                      // 443\n  options = options || {};                                                                                            // 444\n  options = options.hash || options;                                                                                  // 445\n                                                                                                                      // 446\n  var size = self.size(options) || 0;                                                                                 // 447\n  return numeral(size).format(options.formatString || '0.00 b');                                                      // 448\n};                                                                                                                    // 449\n                                                                                                                      // 450\n/**                                                                                                                   // 451\n * @method FS.File.prototype.isUploaded Is this file completely uploaded?                                             // 452\n * @public                                                                                                            // 453\n * @returns {boolean} True if the number of uploaded bytes is equal to the file size.                                 // 454\n */                                                                                                                   // 455\nFS.File.prototype.isUploaded = function() {                                                                           // 456\n  var self = this;                                                                                                    // 457\n                                                                                                                      // 458\n  // Make sure we use the updated file record                                                                         // 459\n  self.getFileRecord();                                                                                               // 460\n                                                                                                                      // 461\n  return !!self.uploadedAt;                                                                                           // 462\n};                                                                                                                    // 463\n                                                                                                                      // 464\n/**                                                                                                                   // 465\n * @method FS.File.prototype.hasStored                                                                                // 466\n * @public                                                                                                            // 467\n * @param {string} storeName Name of the store                                                                        // 468\n * @param {boolean} [optimistic=false] In case that the file record is not found, read below                          // 469\n * @returns {boolean} Is a version of this file stored in the given store?                                            // 470\n *                                                                                                                    // 471\n * > Note: If the file is not published to the client or simply not found:                                            // 472\n * this method cannot know for sure if it exists or not. The `optimistic`                                             // 473\n * param is the boolean value to return. Are we `optimistic` that the copy                                            // 474\n * could exist. This is the case in `FS.File.url` we are optimistic that the                                          // 475\n * copy supplied by the user exists.                                                                                  // 476\n */                                                                                                                   // 477\nFS.File.prototype.hasStored = function(storeName, optimistic) {                                                       // 478\n  var self = this;                                                                                                    // 479\n  // Make sure we use the updated file record                                                                         // 480\n  self.getFileRecord();                                                                                               // 481\n  // If we havent the published data then                                                                             // 482\n  if (FS.Utility.isEmpty(self.copies)) {                                                                              // 483\n    return !!optimistic;                                                                                              // 484\n  }                                                                                                                   // 485\n  if (typeof storeName === \"string\") {                                                                                // 486\n    // Return true only if the `key` property is present, which is not set until                                      // 487\n    // storage is complete.                                                                                           // 488\n    return !!(self.copies && self.copies[storeName] && self.copies[storeName].key);                                   // 489\n  }                                                                                                                   // 490\n  return false;                                                                                                       // 491\n};                                                                                                                    // 492\n                                                                                                                      // 493\n// Backwards compatibility                                                                                            // 494\nFS.File.prototype.hasCopy = FS.File.prototype.hasStored;                                                              // 495\n                                                                                                                      // 496\n/**                                                                                                                   // 497\n * @method FS.File.prototype.getCopyInfo                                                                              // 498\n * @public                                                                                                            // 499\n * @deprecated Use individual methods with `store` option instead.                                                    // 500\n * @param {string} storeName Name of the store for which to get copy info.                                            // 501\n * @returns {Object} The file details, e.g., name, size, key, etc., specific to the copy saved in this store.         // 502\n */                                                                                                                   // 503\nFS.File.prototype.getCopyInfo = function(storeName) {                                                                 // 504\n  var self = this;                                                                                                    // 505\n  // Make sure we use the updated file record                                                                         // 506\n  self.getFileRecord();                                                                                               // 507\n  return (self.copies && self.copies[storeName]) || null;                                                             // 508\n};                                                                                                                    // 509\n                                                                                                                      // 510\n/**                                                                                                                   // 511\n * @method FS.File.prototype._getInfo                                                                                 // 512\n * @private                                                                                                           // 513\n * @param {String} [storeName] Name of the store for which to get file info. Omit for original file details.          // 514\n * @param {Object} [options]                                                                                          // 515\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first?           // 516\n * @returns {Object} The file details, e.g., name, size, key, etc. If not found, returns an empty object.             // 517\n */                                                                                                                   // 518\nFS.File.prototype._getInfo = function(storeName, options) {                                                           // 519\n  var self = this;                                                                                                    // 520\n  options = options || {};                                                                                            // 521\n                                                                                                                      // 522\n  if (options.updateFileRecordFirst) {                                                                                // 523\n    // Make sure we use the updated file record                                                                       // 524\n    self.getFileRecord();                                                                                             // 525\n  }                                                                                                                   // 526\n                                                                                                                      // 527\n  if (storeName) {                                                                                                    // 528\n    return (self.copies && self.copies[storeName]) || {};                                                             // 529\n  } else {                                                                                                            // 530\n    return self.original || {};                                                                                       // 531\n  }                                                                                                                   // 532\n};                                                                                                                    // 533\n                                                                                                                      // 534\n/**                                                                                                                   // 535\n * @method FS.File.prototype._setInfo                                                                                 // 536\n * @private                                                                                                           // 537\n * @param {String} storeName - Name of the store for which to set file info. Non-string will set original file details.\n * @param {String} property - Property to set                                                                         // 539\n * @param {String} value - New value for property                                                                     // 540\n * @param {Boolean} save - Should the new value be saved to the DB, too, or just set in the FS.File properties?       // 541\n * @returns {undefined}                                                                                               // 542\n */                                                                                                                   // 543\nFS.File.prototype._setInfo = function(storeName, property, value, save) {                                             // 544\n  var self = this;                                                                                                    // 545\n  if (typeof storeName === \"string\") {                                                                                // 546\n    self.copies = self.copies || {};                                                                                  // 547\n    self.copies[storeName] = self.copies[storeName] || {};                                                            // 548\n    self.copies[storeName][property] = value;                                                                         // 549\n    save && self._saveChanges(storeName);                                                                             // 550\n  } else {                                                                                                            // 551\n    self.original = self.original || {};                                                                              // 552\n    self.original[property] = value;                                                                                  // 553\n    save && self._saveChanges(\"_original\");                                                                           // 554\n  }                                                                                                                   // 555\n};                                                                                                                    // 556\n                                                                                                                      // 557\n/**                                                                                                                   // 558\n * @method FS.File.prototype.name                                                                                     // 559\n * @public                                                                                                            // 560\n * @param {String|null} [value] - If setting the name, specify the new name as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]                                                                                          // 562\n * @param {Object} [options.store=none,original] - Get or set the name of the version of the file that was saved in this store. Default is the original file name.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.                        // 565\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file name.                    // 566\n */                                                                                                                   // 567\nFS.File.prototype.name = function(value, options) {                                                                   // 568\n  var self = this;                                                                                                    // 569\n                                                                                                                      // 570\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {                  // 571\n    // GET                                                                                                            // 572\n    options = value || {};                                                                                            // 573\n    options = options.hash || options; // allow use as UI helper                                                      // 574\n    return self._getInfo(options.store, options).name;                                                                // 575\n  } else {                                                                                                            // 576\n    // SET                                                                                                            // 577\n    options = options || {};                                                                                          // 578\n    return self._setInfo(options.store, 'name', value, typeof options.save === \"boolean\" ? options.save : true);      // 579\n  }                                                                                                                   // 580\n};                                                                                                                    // 581\n                                                                                                                      // 582\n/**                                                                                                                   // 583\n * @method FS.File.prototype.extension                                                                                // 584\n * @public                                                                                                            // 585\n * @param {String|null} [value] - If setting the extension, specify the new extension (without period) as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]                                                                                          // 587\n * @param {Object} [options.store=none,original] - Get or set the extension of the version of the file that was saved in this store. Default is the original file extension.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.                        // 590\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file extension or an empty string if there isn't one.\n */                                                                                                                   // 592\nFS.File.prototype.extension = function(value, options) {                                                              // 593\n  var self = this;                                                                                                    // 594\n                                                                                                                      // 595\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {                  // 596\n    // GET                                                                                                            // 597\n    options = value || {};                                                                                            // 598\n    return FS.Utility.getFileExtension(self.name(options) || '');                                                     // 599\n  } else {                                                                                                            // 600\n    // SET                                                                                                            // 601\n    options = options || {};                                                                                          // 602\n    var newName = FS.Utility.setFileExtension(self.name(options) || '', value);                                       // 603\n    return self._setInfo(options.store, 'name', newName, typeof options.save === \"boolean\" ? options.save : true);    // 604\n  }                                                                                                                   // 605\n};                                                                                                                    // 606\n                                                                                                                      // 607\n/**                                                                                                                   // 608\n * @method FS.File.prototype.size                                                                                     // 609\n * @public                                                                                                            // 610\n * @param {Number} [value] - If setting the size, specify the new size in bytes as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]                                                                                          // 612\n * @param {Object} [options.store=none,original] - Get or set the size of the version of the file that was saved in this store. Default is the original file size.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.                        // 615\n * @returns {Number|undefined} If setting, returns `undefined`. If getting, returns the file size.                    // 616\n */                                                                                                                   // 617\nFS.File.prototype.size = function(value, options) {                                                                   // 618\n  var self = this;                                                                                                    // 619\n                                                                                                                      // 620\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {                  // 621\n    // GET                                                                                                            // 622\n    options = value || {};                                                                                            // 623\n    options = options.hash || options; // allow use as UI helper                                                      // 624\n    return self._getInfo(options.store, options).size;                                                                // 625\n  } else {                                                                                                            // 626\n    // SET                                                                                                            // 627\n    options = options || {};                                                                                          // 628\n    return self._setInfo(options.store, 'size', value, typeof options.save === \"boolean\" ? options.save : true);      // 629\n  }                                                                                                                   // 630\n};                                                                                                                    // 631\n                                                                                                                      // 632\n/**                                                                                                                   // 633\n * @method FS.File.prototype.type                                                                                     // 634\n * @public                                                                                                            // 635\n * @param {String} [value] - If setting the type, specify the new type as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]                                                                                          // 637\n * @param {Object} [options.store=none,original] - Get or set the type of the version of the file that was saved in this store. Default is the original file type.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.                        // 640\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file type.                    // 641\n */                                                                                                                   // 642\nFS.File.prototype.type = function(value, options) {                                                                   // 643\n  var self = this;                                                                                                    // 644\n                                                                                                                      // 645\n  if (!options && ((typeof value === \"object\" && value !== null) || typeof value === \"undefined\")) {                  // 646\n    // GET                                                                                                            // 647\n    options = value || {};                                                                                            // 648\n    options = options.hash || options; // allow use as UI helper                                                      // 649\n    return self._getInfo(options.store, options).type;                                                                // 650\n  } else {                                                                                                            // 651\n    // SET                                                                                                            // 652\n    options = options || {};                                                                                          // 653\n    return self._setInfo(options.store, 'type', value, typeof options.save === \"boolean\" ? options.save : true);      // 654\n  }                                                                                                                   // 655\n};                                                                                                                    // 656\n                                                                                                                      // 657\n/**                                                                                                                   // 658\n * @method FS.File.prototype.updatedAt                                                                                // 659\n * @public                                                                                                            // 660\n * @param {String} [value] - If setting updatedAt, specify the new date as the first argument. Otherwise the options argument should be first.\n * @param {Object} [options]                                                                                          // 662\n * @param {Object} [options.store=none,original] - Get or set the last updated date for the version of the file that was saved in this store. Default is the original last updated date.\n * @param {Boolean} [options.updateFileRecordFirst=false] Update this instance with data from the DB first? Applies to getter usage only.\n * @param {Boolean} [options.save=true] Save change to database? Applies to setter usage only.                        // 665\n * @returns {String|undefined} If setting, returns `undefined`. If getting, returns the file's last updated date.     // 666\n */                                                                                                                   // 667\nFS.File.prototype.updatedAt = function(value, options) {                                                              // 668\n  var self = this;                                                                                                    // 669\n                                                                                                                      // 670\n  if (!options && ((typeof value === \"object\" && value !== null && !(value instanceof Date)) || typeof value === \"undefined\")) {\n    // GET                                                                                                            // 672\n    options = value || {};                                                                                            // 673\n    options = options.hash || options; // allow use as UI helper                                                      // 674\n    return self._getInfo(options.store, options).updatedAt;                                                           // 675\n  } else {                                                                                                            // 676\n    // SET                                                                                                            // 677\n    options = options || {};                                                                                          // 678\n    return self._setInfo(options.store, 'updatedAt', value, typeof options.save === \"boolean\" ? options.save : true); // 679\n  }                                                                                                                   // 680\n};                                                                                                                    // 681\n                                                                                                                      // 682\nfunction isBasicObject(obj) {                                                                                         // 683\n  return (obj === Object(obj) && Object.getPrototypeOf(obj) === Object.prototype);                                    // 684\n}                                                                                                                     // 685\n                                                                                                                      // 686\n// getPrototypeOf polyfill                                                                                            // 687\nif (typeof Object.getPrototypeOf !== \"function\") {                                                                    // 688\n  if (typeof \"\".__proto__ === \"object\") {                                                                             // 689\n    Object.getPrototypeOf = function(object) {                                                                        // 690\n      return object.__proto__;                                                                                        // 691\n    };                                                                                                                // 692\n  } else {                                                                                                            // 693\n    Object.getPrototypeOf = function(object) {                                                                        // 694\n      // May break if the constructor has been tampered with                                                          // 695\n      return object.constructor.prototype;                                                                            // 696\n    };                                                                                                                // 697\n  }                                                                                                                   // 698\n}                                                                                                                     // 699\n                                                                                                                      // 700\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function () {\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                    //\n// packages/cfs:file/fsFile-server.js                                                                                 //\n//                                                                                                                    //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                      //\n/**                                                                                                                   // 1\n * Notes a details about a storage adapter failure within the file record                                             // 2\n * @param {string} storeName                                                                                          // 3\n * @param {number} maxTries                                                                                           // 4\n * @return {undefined}                                                                                                // 5\n * @todo deprecate this                                                                                               // 6\n */                                                                                                                   // 7\nFS.File.prototype.logCopyFailure = function(storeName, maxTries) {                                                    // 8\n  var self = this;                                                                                                    // 9\n                                                                                                                      // 10\n  // hasStored will update from the fileRecord                                                                        // 11\n  if (self.hasStored(storeName)) {                                                                                    // 12\n    throw new Error(\"logCopyFailure: invalid storeName\");                                                             // 13\n  }                                                                                                                   // 14\n                                                                                                                      // 15\n  // Make sure we have a temporary file saved since we will be                                                        // 16\n  // trying the save again.                                                                                           // 17\n  FS.TempStore.ensureForFile(self);                                                                                   // 18\n                                                                                                                      // 19\n  var now = new Date();                                                                                               // 20\n  var currentCount = (self.failures && self.failures.copies && self.failures.copies[storeName] && typeof self.failures.copies[storeName].count === \"number\") ? self.failures.copies[storeName].count : 0;\n  maxTries = maxTries || 5;                                                                                           // 22\n                                                                                                                      // 23\n  var modifier = {};                                                                                                  // 24\n  modifier.$set = {};                                                                                                 // 25\n  modifier.$set['failures.copies.' + storeName + '.lastAttempt'] = now;                                               // 26\n  if (currentCount === 0) {                                                                                           // 27\n    modifier.$set['failures.copies.' + storeName + '.firstAttempt'] = now;                                            // 28\n  }                                                                                                                   // 29\n  modifier.$set['failures.copies.' + storeName + '.count'] = currentCount + 1;                                        // 30\n  modifier.$set['failures.copies.' + storeName + '.doneTrying'] = (currentCount + 1 >= maxTries);                     // 31\n  self.update(modifier);                                                                                              // 32\n};                                                                                                                    // 33\n                                                                                                                      // 34\n/**                                                                                                                   // 35\n * Has this store permanently failed?                                                                                 // 36\n * @param {String} storeName The name of the store                                                                    // 37\n * @return {boolean} Has this store failed permanently?                                                               // 38\n * @todo deprecate this                                                                                               // 39\n */                                                                                                                   // 40\nFS.File.prototype.failedPermanently = function(storeName) {                                                           // 41\n  var self = this;                                                                                                    // 42\n  return !!(self.failures &&                                                                                          // 43\n            self.failures.copies &&                                                                                   // 44\n            self.failures.copies[storeName] &&                                                                        // 45\n            self.failures.copies[storeName].doneTrying);                                                              // 46\n};                                                                                                                    // 47\n                                                                                                                      // 48\n/**                                                                                                                   // 49\n * @method FS.File.prototype.createReadStream                                                                         // 50\n * @public                                                                                                            // 51\n * @param {String} [storeName]                                                                                        // 52\n * @returns {stream.Readable} Readable NodeJS stream                                                                  // 53\n *                                                                                                                    // 54\n * Returns a readable stream. Where the stream reads from depends on the FS.File instance and whether you pass a store name.\n *                                                                                                                    // 56\n * * If you pass a `storeName`, a readable stream for the file data saved in that store is returned.                  // 57\n * * If you don't pass a `storeName` and data is attached to the FS.File instance (on `data` property, which must be a DataMan instance), then a readable stream for the attached data is returned.\n * * If you don't pass a `storeName` and there is no data attached to the FS.File instance, a readable stream for the file data currently in the temporary store (`FS.TempStore`) is returned.\n *                                                                                                                    // 60\n */                                                                                                                   // 61\nFS.File.prototype.createReadStream = function(storeName) {                                                            // 62\n  var self = this;                                                                                                    // 63\n                                                                                                                      // 64\n  // If we dont have a store name but got Buffer data?                                                                // 65\n  if (!storeName && self.data) {                                                                                      // 66\n    FS.debug && console.log(\"fileObj.createReadStream creating read stream for attached data\");                       // 67\n    // Stream from attached data if present                                                                           // 68\n    return self.data.createReadStream();                                                                              // 69\n  } else if (!storeName && FS.TempStore && FS.TempStore.exists(self)) {                                               // 70\n    FS.debug && console.log(\"fileObj.createReadStream creating read stream for temp store\");                          // 71\n    // Stream from temp store - its a bit slower than regular streams?                                                // 72\n    return FS.TempStore.createReadStream(self);                                                                       // 73\n  } else {                                                                                                            // 74\n    // Stream from the store using storage adapter                                                                    // 75\n    if (self.isMounted()) {                                                                                           // 76\n      var storage = self.collection.storesLookup[storeName] || self.collection.primaryStore;                          // 77\n      FS.debug && console.log(\"fileObj.createReadStream creating read stream for store\", storage.name);               // 78\n      // return stream                                                                                                // 79\n      return storage.adapter.createReadStream(self);                                                                  // 80\n    } else {                                                                                                          // 81\n      throw new Meteor.Error('File not mounted');                                                                     // 82\n    }                                                                                                                 // 83\n                                                                                                                      // 84\n  }                                                                                                                   // 85\n};                                                                                                                    // 86\n                                                                                                                      // 87\n/**                                                                                                                   // 88\n * @method FS.File.prototype.createWriteStream                                                                        // 89\n * @public                                                                                                            // 90\n * @param {String} [storeName]                                                                                        // 91\n * @returns {stream.Writeable} Writeable NodeJS stream                                                                // 92\n *                                                                                                                    // 93\n * Returns a writeable stream. Where the stream writes to depends on whether you pass in a store name.                // 94\n *                                                                                                                    // 95\n * * If you pass a `storeName`, a writeable stream for (over)writing the file data in that store is returned.         // 96\n * * If you don't pass a `storeName`, a writeable stream for writing to the temp store for this file is returned.     // 97\n *                                                                                                                    // 98\n */                                                                                                                   // 99\nFS.File.prototype.createWriteStream = function(storeName) {                                                           // 100\n  var self = this;                                                                                                    // 101\n                                                                                                                      // 102\n  // We have to have a mounted file in order for this to work                                                         // 103\n  if (self.isMounted()) {                                                                                             // 104\n    if (!storeName && FS.TempStore && FS.FileWorker) {                                                                // 105\n      // If we have worker installed - we pass the file to FS.TempStore                                               // 106\n      // We dont need the storeName since all stores will be generated from                                           // 107\n      // TempStore.                                                                                                   // 108\n      // This should trigger FS.FileWorker at some point?                                                             // 109\n      FS.TempStore.createWriteStream(self);                                                                           // 110\n    } else {                                                                                                          // 111\n      // Stream directly to the store using storage adapter                                                           // 112\n      var storage = self.collection.storesLookup[storeName] || self.collection.primaryStore;                          // 113\n      return storage.adapter.createWriteStream(self);                                                                 // 114\n    }                                                                                                                 // 115\n  } else {                                                                                                            // 116\n    throw new Meteor.Error('File not mounted');                                                                       // 117\n  }                                                                                                                   // 118\n};                                                                                                                    // 119\n                                                                                                                      // 120\n/**                                                                                                                   // 121\n * @method FS.File.prototype.copy Makes a copy of the file and underlying data in all stores.                         // 122\n * @public                                                                                                            // 123\n * @returns {FS.File} The new FS.File instance                                                                        // 124\n */                                                                                                                   // 125\nFS.File.prototype.copy = function() {                                                                                 // 126\n  var self = this;                                                                                                    // 127\n                                                                                                                      // 128\n  if (!self.isMounted()) {                                                                                            // 129\n    throw new Error(\"Cannot copy a file that is not associated with a collection\");                                   // 130\n  }                                                                                                                   // 131\n                                                                                                                      // 132\n  // Get the file record                                                                                              // 133\n  var fileRecord = self.collection.files.findOne({_id: self._id}, {transform: null}) || {};                           // 134\n                                                                                                                      // 135\n  // Remove _id and copy keys from the file record                                                                    // 136\n  delete fileRecord._id;                                                                                              // 137\n                                                                                                                      // 138\n  // Insert directly; we don't have access to \"original\" in this case                                                 // 139\n  var newId = self.collection.files.insert(fileRecord);                                                               // 140\n                                                                                                                      // 141\n  var newFile = self.collection.findOne(newId);                                                                       // 142\n                                                                                                                      // 143\n  // Copy underlying files in the stores                                                                              // 144\n  var mod, oldKey;                                                                                                    // 145\n  for (var name in newFile.copies) {                                                                                  // 146\n    if (newFile.copies.hasOwnProperty(name)) {                                                                        // 147\n      oldKey = newFile.copies[name].key;                                                                              // 148\n      if (oldKey) {                                                                                                   // 149\n        // We need to ask the adapter for the true oldKey because                                                     // 150\n        // right now gridfs does some extra stuff.                                                                    // 151\n        // TODO GridFS should probably set the full key object                                                        // 152\n        // (with _id and filename) into `copies.key`                                                                  // 153\n        // so that copies.key can be passed directly to                                                               // 154\n        // createReadStreamForFileKey                                                                                 // 155\n        var sourceFileStorage = self.collection.storesLookup[name];                                                   // 156\n        if (!sourceFileStorage) {                                                                                     // 157\n          throw new Error(name + \" is not a valid store name\");                                                       // 158\n        }                                                                                                             // 159\n        oldKey = sourceFileStorage.adapter.fileKey(self);                                                             // 160\n        // delete so that new fileKey will be generated in copyStoreData                                              // 161\n        delete newFile.copies[name].key;                                                                              // 162\n        mod = mod || {};                                                                                              // 163\n        mod[\"copies.\" + name + \".key\"] = copyStoreData(newFile, name, oldKey);                                        // 164\n      }                                                                                                               // 165\n    }                                                                                                                 // 166\n  }                                                                                                                   // 167\n  // Update keys in the filerecord                                                                                    // 168\n  if (mod) {                                                                                                          // 169\n    newFile.update({$set: mod});                                                                                      // 170\n  }                                                                                                                   // 171\n                                                                                                                      // 172\n  return newFile;                                                                                                     // 173\n};                                                                                                                    // 174\n                                                                                                                      // 175\nMeteor.methods({                                                                                                      // 176\n  // Does a HEAD request to URL to get the type, updatedAt,                                                           // 177\n  // and size prior to actually downloading the data.                                                                 // 178\n  // That way we can do filter checks without actually downloading.                                                   // 179\n  '_cfs_getUrlInfo': function (url, options) {                                                                        // 180\n    check(url, String);                                                                                               // 181\n    check(options, Object);                                                                                           // 182\n                                                                                                                      // 183\n    this.unblock();                                                                                                   // 184\n                                                                                                                      // 185\n    var response = HTTP.call(\"HEAD\", url, options);                                                                   // 186\n    var headers = response.headers;                                                                                   // 187\n    var result = {};                                                                                                  // 188\n                                                                                                                      // 189\n    if (headers['content-type']) {                                                                                    // 190\n      result.type = headers['content-type'];                                                                          // 191\n    }                                                                                                                 // 192\n                                                                                                                      // 193\n    if (headers['content-length']) {                                                                                  // 194\n      result.size = +headers['content-length'];                                                                       // 195\n    }                                                                                                                 // 196\n                                                                                                                      // 197\n    if (headers['last-modified']) {                                                                                   // 198\n      result.updatedAt = new Date(headers['last-modified']);                                                          // 199\n    }                                                                                                                 // 200\n                                                                                                                      // 201\n    return result;                                                                                                    // 202\n  }                                                                                                                   // 203\n});                                                                                                                   // 204\n                                                                                                                      // 205\n// TODO maybe this should be in cfs-storage-adapter                                                                   // 206\nfunction _copyStoreData(fileObj, storeName, sourceKey, callback) {                                                    // 207\n  if (!fileObj.isMounted()) {                                                                                         // 208\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");                    // 209\n  }                                                                                                                   // 210\n                                                                                                                      // 211\n  var storage = fileObj.collection.storesLookup[storeName];                                                           // 212\n  if (!storage) {                                                                                                     // 213\n    throw new Error(storeName + \" is not a valid store name\");                                                        // 214\n  }                                                                                                                   // 215\n                                                                                                                      // 216\n  // We want to prevent beforeWrite and transformWrite from running, so                                               // 217\n  // we interact directly with the store.                                                                             // 218\n  var destinationKey = storage.adapter.fileKey(fileObj);                                                              // 219\n  var readStream = storage.adapter.createReadStreamForFileKey(sourceKey);                                             // 220\n  var writeStream = storage.adapter.createWriteStreamForFileKey(destinationKey);                                      // 221\n                                                                                                                      // 222\n  writeStream.once('stored', function(result) {                                                                       // 223\n    callback(null, result.fileKey);                                                                                   // 224\n  });                                                                                                                 // 225\n                                                                                                                      // 226\n  writeStream.once('error', function(error) {                                                                         // 227\n    callback(error);                                                                                                  // 228\n  });                                                                                                                 // 229\n                                                                                                                      // 230\n  readStream.pipe(writeStream);                                                                                       // 231\n}                                                                                                                     // 232\nvar copyStoreData = Meteor.wrapAsync(_copyStoreData);                                                                 // 233\n                                                                                                                      // 234\n/**                                                                                                                   // 235\n * @method FS.File.prototype.copyData Copies the content of a store directly into another store.                      // 236\n * @public                                                                                                            // 237\n * @param {string} sourceStoreName                                                                                    // 238\n * @param {string} targetStoreName                                                                                    // 239\n * @param {boolean=} move                                                                                             // 240\n */                                                                                                                   // 241\nFS.File.prototype.copyData = function(sourceStoreName, targetStoreName, move){                                        // 242\n                                                                                                                      // 243\n  move = !!move;                                                                                                      // 244\n  /**                                                                                                                 // 245\n   * @type {Object.<string,*>}                                                                                        // 246\n   */                                                                                                                 // 247\n  var sourceStoreValues = this.copies[sourceStoreName];                                                               // 248\n  /**                                                                                                                 // 249\n   * @type {string}                                                                                                   // 250\n   */                                                                                                                 // 251\n  var copyKey = cloneDataToStore(this, sourceStoreName, targetStoreName, move);                                       // 252\n  /**                                                                                                                 // 253\n   * @type {Object.<string,*>}                                                                                        // 254\n   */                                                                                                                 // 255\n  var targetStoreValues = {};                                                                                         // 256\n  for (var v in sourceStoreValues) {                                                                                  // 257\n    if (sourceStoreValues.hasOwnProperty(v)) {                                                                        // 258\n      targetStoreValues[v] = sourceStoreValues[v]                                                                     // 259\n    }                                                                                                                 // 260\n  }                                                                                                                   // 261\n  targetStoreValues.key = copyKey;                                                                                    // 262\n  targetStoreValues.createdAt = new Date();                                                                           // 263\n  targetStoreValues.updatedAt = new Date();                                                                           // 264\n  /**                                                                                                                 // 265\n   *                                                                                                                  // 266\n   * @type {modifier}                                                                                                 // 267\n   */                                                                                                                 // 268\n  var modifier = {};                                                                                                  // 269\n  modifier.$set = {};                                                                                                 // 270\n  modifier.$set[\"copies.\"+targetStoreName] = targetStoreValues;                                                       // 271\n  if(move){                                                                                                           // 272\n    modifier.$unset = {};                                                                                             // 273\n    modifier.$unset[\"copies.\"+sourceStoreName] = \"\";                                                                  // 274\n  }                                                                                                                   // 275\n  this.update(modifier);                                                                                              // 276\n};                                                                                                                    // 277\n/**                                                                                                                   // 278\n * @method FS.File.prototype.moveData Moves the content of a store directly into another store.                       // 279\n * @public                                                                                                            // 280\n * @param {string} sourceStoreName                                                                                    // 281\n * @param {string} targetStoreName                                                                                    // 282\n */                                                                                                                   // 283\nFS.File.prototype.moveData = function(sourceStoreName, targetStoreName){                                              // 284\n  this.copyData(sourceStoreName, targetStoreName, true);                                                              // 285\n};                                                                                                                    // 286\n// TODO maybe this should be in cfs-storage-adapter                                                                   // 287\n/**                                                                                                                   // 288\n *                                                                                                                    // 289\n * @param {FS.File} fileObj                                                                                           // 290\n * @param {string} sourceStoreName                                                                                    // 291\n * @param {string} targetStoreName                                                                                    // 292\n * @param {boolean} move                                                                                              // 293\n * @param callback                                                                                                    // 294\n * @private                                                                                                           // 295\n */                                                                                                                   // 296\nfunction _copyDataFromStoreToStore(fileObj, sourceStoreName, targetStoreName, move, callback) {                       // 297\n  if (!fileObj.isMounted()) {                                                                                         // 298\n    throw new Error(\"Cannot copy store data for a file that is not associated with a collection\");                    // 299\n  }                                                                                                                   // 300\n  /**                                                                                                                 // 301\n   * @type {FS.StorageAdapter}                                                                                        // 302\n   */                                                                                                                 // 303\n  var sourceStorage = fileObj.collection.storesLookup[sourceStoreName];                                               // 304\n  /**                                                                                                                 // 305\n   * @type {FS.StorageAdapter}                                                                                        // 306\n   */                                                                                                                 // 307\n  var targetStorage = fileObj.collection.storesLookup[targetStoreName];                                               // 308\n                                                                                                                      // 309\n  if (!sourceStorage) {                                                                                               // 310\n    throw new Error(sourceStoreName + \" is not a valid store name\");                                                  // 311\n  }                                                                                                                   // 312\n  if (!targetStorage) {                                                                                               // 313\n    throw new Error(targetStorage + \" is not a valid store name\");                                                    // 314\n  }                                                                                                                   // 315\n                                                                                                                      // 316\n  // We want to prevent beforeWrite and transformWrite from running, so                                               // 317\n  // we interact directly with the store.                                                                             // 318\n  var sourceKey = sourceStorage.adapter.fileKey(fileObj);                                                             // 319\n  var targetKey = targetStorage.adapter.fileKey(fileObj);                                                             // 320\n  var readStream = sourceStorage.adapter.createReadStreamForFileKey(sourceKey);                                       // 321\n  var writeStream = targetStorage.adapter.createWriteStreamForFileKey(targetKey);                                     // 322\n                                                                                                                      // 323\n                                                                                                                      // 324\n  writeStream.safeOnce('stored', function(result) {                                                                   // 325\n    if(move && sourceStorage.adapter.remove(fileObj)===false){                                                        // 326\n      callback(\"Copied to store:\" + targetStoreName                                                                   // 327\n      + \" with fileKey: \"                                                                                             // 328\n      + result.fileKey                                                                                                // 329\n      + \", but could not delete from source store: \"                                                                  // 330\n      + sourceStoreName);                                                                                             // 331\n    }else{                                                                                                            // 332\n      callback(null, result.fileKey);                                                                                 // 333\n    }                                                                                                                 // 334\n  });                                                                                                                 // 335\n                                                                                                                      // 336\n  writeStream.once('error', function(error) {                                                                         // 337\n    callback(error);                                                                                                  // 338\n  });                                                                                                                 // 339\n                                                                                                                      // 340\n  readStream.pipe(writeStream);                                                                                       // 341\n}                                                                                                                     // 342\nvar cloneDataToStore = Meteor.wrapAsync(_copyDataFromStoreToStore);                                                   // 343\n                                                                                                                      // 344\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}