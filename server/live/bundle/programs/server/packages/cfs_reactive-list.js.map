{"version":3,"sources":["meteor://ðŸ’»app/packages/cfs_reactive-list/packages/cfs_reactive-list.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yG","file":"/packages/cfs_reactive-list.js","sourcesContent":["(function () {\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                          //\n// packages/cfs:reactive-list/reactive-list.js                                              //\n//                                                                                          //\n//////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                            //\n// #ReactiveList                                                                            // 1\n// Provides a simple reactive list interface                                                // 2\nvar _noopCallback = function() {};                                                          // 3\n                                                                                            // 4\nvar _nonReactive = {                                                                        // 5\n  changed: _noopCallback,                                                                   // 6\n  depend: _noopCallback                                                                     // 7\n};                                                                                          // 8\n                                                                                            // 9\n/** @method ReactiveList Keeps a reactive list of key+value items                           // 10\n  * @constructor                                                                            // 11\n  * @namespace ReactiveList                                                                 // 12\n  * @param {object} [options]                                                               // 13\n  * @param {function} sort The sort algorithm to use                                        // 14\n  * @param {boolean} [reactive=true] If set false this list is not reactive                 // 15\n  * Example:                                                                                // 16\n  * ```js                                                                                   // 17\n  *   var list = new ReactiveList();                                                        // 18\n  *   list.insert(1, { text: 'Hello id: 1' });                                              // 19\n  *   list.insert(2, { text: 'Hello id: 2' });                                              // 20\n  *   list.insert(3, { text: 'Hello id: 3' });                                              // 21\n  *   list.update(2, { text: 'Updated 2'});                                                 // 22\n  *   list.remove(1);                                                                       // 23\n  *                                                                                         // 24\n  *   list.forEach(function(value, key) {                                                   // 25\n  *     console.log('GOT: ' + value.text);                                                  // 26\n  *   }, true); // Set noneReactive = true, default behaviour is reactive                   // 27\n  *                                                                                         // 28\n  *   // Return from Template:                                                              // 29\n  *   Template.hello.list = function() {                                                    // 30\n  *     return list.fetch();                                                                // 31\n  *   };                                                                                    // 32\n  * ```                                                                                     // 33\n  *                                                                                         // 34\n  * ####Example of a sort algorithm                                                         // 35\n  * Sort can be used to define the order of the list                                        // 36\n  * ```js                                                                                   // 37\n  *   var list = new ReactiveList({                                                         // 38\n  *     sort: function(a, b) {                                                              // 39\n  *       // a and b are type of { key, value }                                             // 40\n  *       // here we sort by the key:                                                       // 41\n  *       return a.key < b.key;                                                             // 42\n  *     }                                                                                   // 43\n  *   });                                                                                   // 44\n  * ```                                                                                     // 45\n  * ###Object chain                                                                         // 46\n  * ```                                                                                     // 47\n  *                   first                               last                              // 48\n  *  undefined -       obj       -       obj       -       obj       - undefined            // 49\n  *             (prev value next) (prev value next) (prev value next)                       // 50\n  * ```                                                                                     // 51\n  */                                                                                        // 52\nReactiveList = function(options) {                                                          // 53\n  var self = this;                                                                          // 54\n  // Object container                                                                       // 55\n  self.lookup = {};                                                                         // 56\n  // Length                                                                                 // 57\n  self._length = 0;                                                                         // 58\n  // First object in list                                                                   // 59\n  self.first;                                                                               // 60\n  // Last object in list                                                                    // 61\n  self.last;                                                                                // 62\n  // Set sort to options.sort or default to true (asc)                                      // 63\n  self.sort = (options && options.sort || function(a, b) {                                  // 64\n    return a.key < b.key;                                                                   // 65\n  });                                                                                       // 66\n                                                                                            // 67\n  // Allow user to disable reactivity, default true                                         // 68\n  self.isReactive = (options)? options.reactive !== false : true;                           // 69\n                                                                                            // 70\n  // If lifo queue                                                                          // 71\n  if (options === true || options && options.sort === true) {                               // 72\n    self.sort = function(a, b) { return a.key > b.key; };                                   // 73\n  }                                                                                         // 74\n                                                                                            // 75\n  // Rig the dependencies                                                                   // 76\n  self._listDeps = (self.isReactive)? new Deps.Dependency() : _nonReactive;                 // 77\n                                                                                            // 78\n  self._lengthDeps = (self.isReactive)? new Deps.Dependency() : _nonReactive;               // 79\n};                                                                                          // 80\n                                                                                            // 81\n/** @method ReactiveList.prototype.length Returns the length of the list                    // 82\n  * @reactive                                                                               // 83\n  * @returns {number} Length of the reactive list                                           // 84\n  */                                                                                        // 85\nReactiveList.prototype.length = function() {                                                // 86\n  var self = this;                                                                          // 87\n  // Make this reactive                                                                     // 88\n  self._lengthDeps.depend();                                                                // 89\n  return self._length;                                                                      // 90\n};                                                                                          // 91\n                                                                                            // 92\n/** @method ReactiveList.prototype.reset Reset and empty the list                           // 93\n  * @todo Check for memory leaks, if so we have to iterate over lookup and delete the items // 94\n  */                                                                                        // 95\nReactiveList.prototype.reset = function() {                                                 // 96\n  var self = this;                                                                          // 97\n  // Clear the reference to the first object                                                // 98\n  self.first = undefined;                                                                   // 99\n  // Clear the reference to the last object                                                 // 100\n  self.last = undefined;                                                                    // 101\n  // Clear the lookup object                                                                // 102\n  self.lookup = {};                                                                         // 103\n  // Set the length to 0                                                                    // 104\n  self._length = 0;                                                                         // 105\n  self._lengthDeps.changed();                                                               // 106\n  // Invalidate the list                                                                    // 107\n  self._listDeps.changed();                                                                 // 108\n};                                                                                          // 109\n                                                                                            // 110\n/** @method ReactiveList.prototype.update                                                   // 111\n  * @param {string|number} key Key to update                                                // 112\n  * @param {any} value Update with this value                                               // 113\n  */                                                                                        // 114\nReactiveList.prototype.update = function(key, value) {                                      // 115\n  var self = this;                                                                          // 116\n  // Make sure the key is found in the list                                                 // 117\n  if (typeof self.lookup[key] === 'undefined') {                                            // 118\n    throw new Error('Reactive list cannot update, key \"' + key + '\" not found');            // 119\n  }                                                                                         // 120\n  // Set the new value                                                                      // 121\n  self.lookup[key].value = value;                                                           // 122\n  // Invalidate the list                                                                    // 123\n  self._listDeps.changed();                                                                 // 124\n};                                                                                          // 125\n                                                                                            // 126\n/** @method ReactiveList.prototype.insert                                                   // 127\n  * @param {string|number} key Key to insert                                                // 128\n  * @param {any} value Insert item with this value                                          // 129\n  */                                                                                        // 130\nReactiveList.prototype.insert = function(key, value) {                                      // 131\n  var self = this;                                                                          // 132\n  if (typeof self.lookup[key] !== 'undefined') {                                            // 133\n    throw new Error('Reactive list could not insert: key \"' + key +                         // 134\n            '\" allready found');                                                            // 135\n  }                                                                                         // 136\n  // Create the new item to insert into the list                                            // 137\n  var newItem = { key: key, value: value };                                                 // 138\n  // Init current by pointing it at the first object in the list                            // 139\n  var current = self.first;                                                                 // 140\n  // Init the isInserted flag                                                               // 141\n  var isInserted = false;                                                                   // 142\n                                                                                            // 143\n                                                                                            // 144\n  // Iterate through list while not empty and item is not inserted                          // 145\n  while (typeof current !== 'undefined' && !isInserted) {                                   // 146\n                                                                                            // 147\n    // Sort the list by using the sort function                                             // 148\n    if (self.sort(newItem, current)) {                                                      // 149\n                                                                                            // 150\n      // Insert self.lookup[key] before                                                     // 151\n      if (typeof current.prev === 'undefined') { self.first = newItem; }                    // 152\n                                                                                            // 153\n      // Set the references in the inserted object                                          // 154\n      newItem.prev = current.prev;                                                          // 155\n      newItem.next = current;                                                               // 156\n                                                                                            // 157\n      // Update the two existing objects                                                    // 158\n      if (current.prev) { current.prev.next = newItem; }                                    // 159\n      current.prev = newItem;                                                               // 160\n                                                                                            // 161\n      // Mark the item as inserted - job's done                                             // 162\n      isInserted = true;                                                                    // 163\n    }                                                                                       // 164\n    // Goto next object                                                                     // 165\n    current = current.next;                                                                 // 166\n  }                                                                                         // 167\n                                                                                            // 168\n                                                                                            // 169\n  if (!isInserted) {                                                                        // 170\n    // We append it to the list                                                             // 171\n    newItem.prev = self.last;                                                               // 172\n    if (self.last) { self.last.next = newItem; }                                            // 173\n                                                                                            // 174\n    // Update the last pointing to newItem                                                  // 175\n    self.last = newItem;                                                                    // 176\n    // Update first if we are appending to an empty list                                    // 177\n    if (self._length === 0) { self.first = newItem; }                                       // 178\n  }                                                                                         // 179\n                                                                                            // 180\n                                                                                            // 181\n  // Reference the object for a quick lookup option                                         // 182\n  self.lookup[key] = newItem;                                                               // 183\n  // Increase length                                                                        // 184\n  self._length++;                                                                           // 185\n  self._lengthDeps.changed();                                                               // 186\n  // And invalidate the list                                                                // 187\n  self._listDeps.changed();                                                                 // 188\n};                                                                                          // 189\n                                                                                            // 190\n/** @method ReactiveList.prototype.remove                                                   // 191\n  * @param {string|number} key Key to remove                                                // 192\n  */                                                                                        // 193\nReactiveList.prototype.remove = function(key) {                                             // 194\n  var self = this;                                                                          // 195\n  // Get the item object                                                                    // 196\n  var item = self.lookup[key];                                                              // 197\n                                                                                            // 198\n  // Check that it exists                                                                   // 199\n  if (typeof item === 'undefined') {                                                        // 200\n    return;                                                                                 // 201\n    // throw new Error('ReactiveList cannot remove item, unknow key \"' + key +              // 202\n    //        '\"');                                                                         // 203\n  }                                                                                         // 204\n                                                                                            // 205\n  // Rig the references                                                                     // 206\n  var prevItem = item.prev;                                                                 // 207\n  var nextItem = item.next;                                                                 // 208\n                                                                                            // 209\n  // Update chain prev object next reference                                                // 210\n  if (typeof prevItem !== 'undefined') {                                                    // 211\n    prevItem.next = nextItem;                                                               // 212\n  } else {                                                                                  // 213\n    self.first = nextItem;                                                                  // 214\n  }                                                                                         // 215\n                                                                                            // 216\n  // Update chain next object prev reference                                                // 217\n  if (typeof nextItem !== 'undefined') {                                                    // 218\n    nextItem.prev = prevItem;                                                               // 219\n  } else {                                                                                  // 220\n    self.last = prevItem;                                                                   // 221\n  }                                                                                         // 222\n                                                                                            // 223\n  // Clean up                                                                               // 224\n  self.lookup[key].last = null;                                                             // 225\n  self.lookup[key].prev = null;                                                             // 226\n  self.lookup[key] = null;                                                                  // 227\n  prevItem = null;                                                                          // 228\n                                                                                            // 229\n  delete self.lookup[key];                                                                  // 230\n  // Decrease the length                                                                    // 231\n  self._length--;                                                                           // 232\n  self._lengthDeps.changed();                                                               // 233\n  // Invalidate the list                                                                    // 234\n  self._listDeps.changed();                                                                 // 235\n};                                                                                          // 236\n                                                                                            // 237\n/** @method ReactiveList.prototype.getLastItem                                              // 238\n  * @returns {any} Pops last item from the list - removes the item from the list            // 239\n  */                                                                                        // 240\nReactiveList.prototype.getLastItem = function(first) {                                      // 241\n  var self = this;                                                                          // 242\n                                                                                            // 243\n  // Get the relevant item first or last                                                    // 244\n  var item = (first)?self.first: self.last;                                                 // 245\n                                                                                            // 246\n  if (typeof item === 'undefined') {                                                        // 247\n    return; // Empty list                                                                   // 248\n  }                                                                                         // 249\n  // Remove the item from the list                                                          // 250\n  self.remove(item.key);                                                                    // 251\n  // Return the value                                                                       // 252\n  return item.value;                                                                        // 253\n};                                                                                          // 254\n                                                                                            // 255\n/** @method ReactiveList.prototype.getFirstItem                                             // 256\n  * @returns {any} Pops first item from the list - removes the item from the list           // 257\n  */                                                                                        // 258\nReactiveList.prototype.getFirstItem = function() {                                          // 259\n  // This gets the first item...                                                            // 260\n  return this.getLastItem(true);                                                            // 261\n};                                                                                          // 262\n                                                                                            // 263\n/** @method ReactiveList.prototype.forEach                                                  // 264\n  * @param {function} f Callback `funciton(value, key)`                                     // 265\n  * @param {boolean} [noneReactive=false] Set true if want to disable reactivity            // 266\n  * @param {boolean} [reverse=false] Set true to reverse iteration `forEachReverse`         // 267\n  */                                                                                        // 268\nReactiveList.prototype.forEach = function(f, noneReactive, reverse) {                       // 269\n  var self = this;                                                                          // 270\n  // Check if f is a function                                                               // 271\n  if (typeof f !== 'function') {                                                            // 272\n    throw new Error('ReactiveList forEach requires a function');                            // 273\n  }                                                                                         // 274\n  // We allow this not to be reactive                                                       // 275\n  if (!noneReactive) { self._listDeps.depend(); }                                           // 276\n  // Set current to the first object                                                        // 277\n  var current = (reverse)?self.last: self.first;                                            // 278\n  // Iterate over the list while its not empty                                              // 279\n  while (current) {                                                                         // 280\n    // Call the callback function                                                           // 281\n    f(current.value, current.key);                                                          // 282\n    // Jump to the next item in the list                                                    // 283\n    current = (reverse)?current.prev: current.next;                                         // 284\n  }                                                                                         // 285\n};                                                                                          // 286\n                                                                                            // 287\n/** @method ReactiveList.prototype.forEachReverse                                           // 288\n  * @param {function} f Callback `funciton(value, key)`                                     // 289\n  * @param {boolean} [noneReactive=false] Set true if want to disable reactivity            // 290\n  */                                                                                        // 291\nReactiveList.prototype.forEachReverse = function(f, noneReactive) {                         // 292\n  // Call forEach with the reverse flag                                                     // 293\n  this.forEach(f, noneReactive, true);                                                      // 294\n};                                                                                          // 295\n                                                                                            // 296\n/** @method ReactiveList.prototype.fetch Returns list as array                              // 297\n  * @param {boolean} [noneReactive=false] Set true if want to disable reactivity            // 298\n  * @reactive This can be disabled                                                          // 299\n  * @returns {array} List of items                                                          // 300\n  */                                                                                        // 301\nReactiveList.prototype.fetch = function(noneReactive) {                                     // 302\n  var self = this;                                                                          // 303\n  // Init the result buffer                                                                 // 304\n  var result = [];                                                                          // 305\n  // Iterate over the list items                                                            // 306\n  self.forEach(function fetchCallback(value) {                                              // 307\n    // Add the item value to the result                                                     // 308\n    result.push(value);                                                                     // 309\n  }, noneReactive);                                                                         // 310\n  // Return the result                                                                      // 311\n  return result;                                                                            // 312\n};                                                                                          // 313\n                                                                                            // 314\n//////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n"]}